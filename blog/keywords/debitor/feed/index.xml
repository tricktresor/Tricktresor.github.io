<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:series="https://publishpress.com/"
	>

<channel>
	<title>Debitor Archive - Tricktresor</title>
	<atom:link href="/blog/keywords/debitor/feed/" rel="self" type="application/rss+xml" />
	<link></link>
	<description>Tipps und Tricks zu SAP R/3</description>
	<lastBuildDate>Tue, 04 Dec 2018 17:33:38 +0000</lastBuildDate>
	<language>de-DE</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.4.3</generator>

<image>
	<url>/wp-content/uploads/2019/02/cropped-Tricktresor-favicon-2019-32x32.png</url>
	<title>Debitor Archive - Tricktresor</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Buchungsbelege erstellen</title>
		<link>/blog/buchungsbelege-erstellen/</link>
		
		<dc:creator><![CDATA[Enno Wulff]]></dc:creator>
		<pubDate>Thu, 28 Jun 2018 13:48:59 +0000</pubDate>
				<category><![CDATA[Info/ Doku/ Demo]]></category>
		<category><![CDATA[Programmierung]]></category>
		<category><![CDATA[Finanz- und Rechnungswesen]]></category>
		<category><![CDATA[Debitor]]></category>
		<category><![CDATA[Sachkonto]]></category>
		<category><![CDATA[Ergebnisobjekt]]></category>
		<category><![CDATA[FI-Beleg]]></category>
		<category><![CDATA[CO-Beleg]]></category>
		<category><![CDATA[Kreditor]]></category>
		<guid isPermaLink="false">https://tricktresor.com/?p=1018903</guid>

					<description><![CDATA[<p>Folgend ein Report, der exemplarisch zeigt, wie FI-Belege gebucht werden k√∂nnen. Es werden Die Bausteine BAPI_ACC_DOCUMENT_CHECK und BAPI_ACC_DOCUMENT_POST verwendet. Aktuell macht der Report gar nichts! Die Kopf- und Positionsdaten m√ºssen in LT_BKPF und LT_BSEG entsprechend eingef√ºgt werden. Wie genau das geht, erf√§hrst du in dieser ausf√ºhrlichen Doku: Dokumentation FI Buchungen mittels BAPI_ACC_DOCUMENT_POST Vorgaben Ich gehe davon aus, das die zu buchenden Daten in der Form Kopf/Position vorliegen. Sollte dies nicht der Fall sein, so sollten...</p>
<p>Der Beitrag <a href="/blog/buchungsbelege-erstellen/">Buchungsbelege erstellen</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Folgend ein Report, der exemplarisch zeigt, wie FI-Belege gebucht werden k√∂nnen. Es werden Die Bausteine BAPI_ACC_DOCUMENT_CHECK und BAPI_ACC_DOCUMENT_POST verwendet.</p>
<p>Aktuell macht der Report gar nichts!</p>
<p>Die Kopf- und Positionsdaten m√ºssen in LT_BKPF und LT_BSEG entsprechend eingef√ºgt werden. Wie genau das geht, erf√§hrst du in dieser ausf√ºhrlichen Doku:</p>
<h2>Dokumentation</h2>
<p><a href="https://tricktresor.com/wp-content/uploads/2018/06/FI-Buchungen-mittels-BAPI_ACC_DOCUMENT_POST.pdf">FI Buchungen mittels BAPI_ACC_DOCUMENT_POST</a></p>
<h2>Vorgaben</h2>
<p>Ich gehe davon aus, das die zu buchenden Daten in der Form Kopf/Position vorliegen. Sollte dies nicht der Fall sein, so sollten diese vorher so aufbereitet werden, da dies den Umgang beim Programmieren wesentlich vereinfacht.</p>
<p>Das folgende Beispiel behandelt exemplarisch eine kreditorische Buchung,<br />
l√§√üt sich jedoch prinzipiell ebenso auf debitorische oder Sachkonten-<br />
buchungen √ºbertragen.<br />
Als Schmankerl wird ein zus√§tzliches Feld, welches nicht in der Sachkontenzeile<br />
enthalten ist (LZBKZ &#8211; Landeszentralbankkennzeichen) mitgegeben und die Steuer<br />
mit einem Steuerschema gebucht, welches zwei Steuerzeilen enth√§lt.</p>
<p>Prinzipiell muss man folgendes Wissen zur Buchung von FI-Belegen wissen:</p>
<ol>
<li>Die erste Zeile des zu buchenden Beleges enth√§lt den Betrag IMMER als Brutto-Wert! Unabh√§ngig davon ob diese kreditorisch, debitorisch oder eine Sachkontenbuchung ist.</li>
<li>Bei kreditorischen oder debitorischen Buchungen tauchen diese als Zeile nur ein mal als erste Zeile auf!</li>
<li>Steuerkennzeichen M√úSSEN mitgeliefert werden sonst kann keine Steuer gebucht werden.</li>
</ol>
<h3>Kopfdaten</h3>
<p>Wenn die Daten aus einem R3-System kommen, liegen die Daten normalerweise in der Form BUKRS/BELNR/GJAHR + Datenteil (f√ºr BKPF/BSEG) vor.<br />
Sollte dies nicht der Fall, so erh√§lt man normalerweise, wie in diesem Beispiel, eine laufende, eindeutige Nummer als Identifikator.<br />
F√ºr den Kopf auf jeden Fall m√ºssen mitgegeben werden:</p>
<ul>
<li>BUDAT &#8211; Buchungsdatum</li>
<li>BLDAT &#8211; Belegdatum</li>
<li>BUKRS &#8211; Buchungskreis</li>
<li>BLART &#8211; Belegart</li>
<li>WAERS &#8211; W√§hrung in der gebucht werden soll (Belegw√§hrung)</li>
</ul>
<p>Bei Fremdw√§hrungsbuchungen m√ºssen zus√§tzlich das Feld</p>
<ul>
<li>KURSF &#8211; Umrechnungskurs zur Buchungskreisw√§hrung (Zeilentyp BAPIACCR09)<br />
<em><strong>ODER!!!!</strong></em></li>
<li>WWERT &#8211; Umrechnungsdatum (Zeilentyp BAPIACHE09)</li>
</ul>
<p>mitgegeben werden &#8211; keinesfalls beide!</p>
<p>Bei kreditorischen Buchungen ist z.B. auch die Referenz zu f√ºllen</p>
<ul>
<li>XBLNR &#8211; Referenznummer (Belegnummer des Lieferanten)</li>
</ul>
<p>All diese Werte m√ºssen bekannt sein und mitgegeben werden.</p>
<p>Das Buchungsdatum kann auch leer gelassen werden, dann wird aus dem Systemdatum die entsprechenden Werte f√ºr GJAHR und POPER errechnet (siehe Routine ADD_DATA_BKPF).<br />
Ansonsten wird das mitgegebene Buchungsdatum verwendet und zur Berechnung verwendet</p>
<ul>
<li>BKTXT &#8211; Kopftext (braucht man manchmal)</li>
</ul>
<h2>Positionsdaten</h2>
<ul>
<li>Als Mussdaten sind notwendig:</li>
<li>BUZEI fortlaufende Buchungszeilennummer.<br />
Kann man auch &#8220;on the fly&#8221; erzeugen einfacher ist es, wenn sie bereits gef√ºllt ist. Die Buchungszeile stellt √ºber den in jedem Segment vorhandenen Parameter ITEMNO_ACC die Verbindung bzw. die Sortierung der einzelnen Zeilen des Beleges untereinander sicher</li>
<li>KOART Kontoart<br />
K &#8211; Kreditorische Buchungszeile, D &#8211; Debitorische Buchungszeile,<br />
S &#8211; Sachkontenzeile</li>
<li>SHKZG Soll-/Haben Kennzeichen S/H<br />
Auch aus Fremdsystemen erh√§lt man normalerweise dieses Kennzeichen. Es dient dazu, das Vorzeichen f√ºr die Betr√§ge, welche dem BAPI √ºbergeben werden, richtig zu ermitteln. Dies setzt voraus, das die Betr√§ge (!!) immer als positive Werte √ºbergeben werden &#8211; was im R/3 immer der Fall ist und bei Fremdsystembelegen zu 99% (SAP hat schlie√ülich die Buchhaltung nicht erfunden <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/1f609.png" alt="üòâ" class="wp-smiley" style="height: 1em; max-height: 1em;" /> )<br />
Habenwerte sind hierbei immmer mit -1 zu multiplizieren, Sollwerte behalten Ihr positives Vorzeichen</li>
<li>GKONT Gegenkonto<br />
Im Fall einer kreditorischen bzw. debitorischen Zeile die Lieferanten- bzw. Kundennummer. Im Fall einer Sachkontenzeile die Kontonummer, auf welche gebucht werden soll</li>
<li>MWSKZ Mehrwertsteuerkennzeichen<br />
MUSS, im Falle einer ggf. zu buchenden Steuer, mitgegeben werden. Hier√ºber werden die zu buchenden Steuerzeilen ermittelt</li>
<li>BRUTTO Bruttowert der Buchungszeile. Wird immer benutzt bei &#8220;Kopfzeilen&#8221; d.h. bei kreditorische, debitorischen oder der 1. Zeile eines Sachkontenbeleges</li>
<li>NETTO Nettowert der Buchungszeile d.h. ohne Steuer<br />
Wird bei allen &#8220;Positionszeilen&#8221;, d.h. ab Zeile 2 des Beleges benutzt</li>
</ul>
<h3>Kontierungen</h3>
<p>Im Beispiel habe ich Kontierungen auf Kostenstellen, Innenauftr√§ge, SD-Belege und Anlagen vorgesehen.</p>
<ul>
<li>SGTXT Positionstext (braucht man manchmal)</li>
<li>LANDL Lieferland<br />
Wird ben√∂tigt, wenn der Lieferant im Ausland ans√§ssig ist &#8211; kann man aber auch durch nachlesen des Landes aus der Adresse des Lieferanten holen. Hier der Einfachheit halber in der Struktur</li>
</ul>
<h4>Schmankerl 1</h4>
<ul>
<li>LZBKZ Landeszentralbankkennzeichen<br />
Die betrifft Rechnungen von ausl√§ndischen Lieferanten die eine Sonstige Leistung i.S. des Umsatzsteuergesetzes erbracht haben. Der ¬ß13b UStG regelt unter einzelnen Punkten in welchen F√§llen der Leistungsempf√§nger f√ºr die Leistungen die Umsatzsteuer schuldet.<br />
Gleichzeitig darf der Leistungsempf√§nger sich diesen Betrag als Vorsteuer in Abzug bringen.<br />
Steht in der BSEG als Feld zur Verf√ºgung, ist aber nicht in der kreditorischen Struktur BAPIACAP09 vorhanden!!! Mu√ü √ºber die Tabelle extension2 des BAPI&#8217;s √ºbergeben werden<br />
Ausf√ºhrungen dazu in der Unterroutine f√ºr die Kreditorenzeile</li>
</ul>
<h4>Schmankerl 2</h4>
<ul>
<li>CO-PA Kontierung<br />
Bei Kontierung auf CO-PA Objekte (Ergebnisobjekte) kommt es oft genug vor, das vom Kunden nur der Vertriebsbeleg vorgegeben wird und alles andere soll ermittelt werden. Wir befinden uns nicht in der FB01 oder FB60 und k√∂nnen auf den Knopf &#8220;Ableitung&#8221; dr√ºcken.<br />
Was also tun? Siehe hierzu die Unterroutine &#8220;ADD_COPA_LINE&#8217;.</li>
</ul>
<h2>Coding</h2>
<pre class="lang:abap decode:true">*&amp;---------------------------------------------------------------------*
*&amp; Report Z_POST_ACC_DOCUMENT
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;---------------------------------------------------------------------*
REPORT z_post_acc_document.

******** KOPFDATEN **************
TYPES: BEGIN OF gtys_bkpf,
         id    TYPE numc10,
         bukrs TYPE bkpf-bukrs,
         gjahr TYPE bkpf-gjahr,
         poper TYPE poper,
         blart TYPE bkpf-blart,
         bldat TYPE bkpf-bldat,
         budat TYPE bkpf-budat,
         xblnr TYPE bkpf-xblnr,
         bktxt TYPE bkpf-bktxt,
         waers TYPE bkpf-waers,
         kursf TYPE bkpf-kursf,
         wwert TYPE bkpf-wwert,
         belnr TYPE bkpf-belnr,
       END OF gtys_bkpf,
       gtyt_bkpf TYPE STANDARD TABLE OF gtys_bkpf.

******** POSITIONSDATEN ***********
* Schmankerl 1
* LZBKZ  Landeszentralbankkennzeichen
*        Die betrifft Rechnungen von ausl√§ndischen Lieferanten die eine Sonstige Leistung
*        i.S. des Umsatzsteuergesetzes erbracht haben. Der ¬ß13b UStG regelt unter einzelnen
*        Punkten in welchen F√§llen der Leistungsempf√§nger f√ºr die Leistungen die Umsatzsteuer schuldet.
*        Gleichzeitig darf der Leistungsempf√§nger sich diesen Betrag als Vorsteuer in Abzug bringen.
*        Steht in der BSEG als Feld zur Verf√ºgung, ist aber nicht in der kreditorischen
*        Struktur BAPIACAP09 vorhanden!!! Mu√ü √ºber die Tabelle extension2 des BAPI's √ºbergeben werden
*        Ausf√ºhrungen dazu in der Unterroutine f√ºr die Kreditorenzeile "ADD_CRED_LINE"
* Schmankerl 2
* VBELN   CO-PA Kontierung
*        Bei Kontierung auf CO-PA Objekte (Ergebnisobjekte) kommt es oft genug vor,
*        das vom Kunden nur der Vertriebsbeleg vorgegeben wird und alles andere soll
*        ermittelt werden. Wir befinden uns nicht in der FB01 oder FB60 und k√∂nnen auf
*        den Knopf "Ableitung" dr√ºcken.
*        Was also tun?
*        Siehe hierzu die Unterroutine "ADD_COPA_LINE'.
* Schmankerl 3
* BWASL  Bewegungsartenschl√ºssel
*        Bei der direkten Buchung von Kreditor auf Anlage mu√ü der Bewegungsartenschl√ºssel
*        vorgegeben werden. Dieser ist zwingend notwendig, sonst kommt keine Buchung zustande
*        bzw. wird abgelehnt.
*        N√§heres hierzu in der Unterroutine "ADD_SACH_LINE'.
TYPES: BEGIN OF gtys_bseg,
         id     TYPE numc10,
         buzei  TYPE bseg-buzei,
         koart  TYPE bseg-koart,
         shkzg  TYPE bseg-shkzg,
         gkont  TYPE gkont,
         brutto TYPE bseg-wrbtr,
         netto  TYPE bseg-wrbtr,
         mwskz  TYPE bseg-mwskz,
         sgtxt  TYPE bseg-sgtxt,
         kostl  TYPE bseg-kostl,
         aufnr  TYPE bseg-aufnr,
         vbeln  TYPE bseg-vbeln,
         posnr  TYPE bseg-posn2,
         anln1  TYPE bseg-anln1,
         anln2  TYPE bseg-anln2,
         lzbkz  TYPE bseg-lzbkz,
         landl  TYPE bseg-landl,
         bwasl  TYPE bwasl,
       END OF gtys_bseg,
       gtyt_bseg TYPE STANDARD TABLE OF gtys_bseg.

* Struktur f√ºr den Aufbau der Steuerzeilen
TYPES: BEGIN OF gtys_tax,
         mwskz TYPE mwskz,
         wmwst TYPE wmwst,
         msatz TYPE msatz_f05l,
         ktosl TYPE ktosl,
         kawrt TYPE kawrt,
         hkont TYPE hkont,
         kschl TYPE kschl,
       END OF gtys_tax,
       gtyt_tax TYPE STANDARD TABLE OF gtys_tax.

* Org-Daten f√ºr CO-PA Ermittlung
TYPES: BEGIN OF gtys_org_copa,
         bukrs TYPE bukrs,
         kokrs TYPE kokrs,
         erkrs TYPE erkrs,
       END OF gtys_org_copa,
       gtyt_org_copa_hash TYPE HASHED TABLE OF gtys_org_copa
                       WITH UNIQUE KEY bukrs.
* Neue CO-PA Ableitung
TYPES: gtyt_copadata TYPE copadata_tab.

* Testparameter
PARAMETERS: p_xtest TYPE xfeld DEFAULT 'X'.

START-OF-SELECTION.
  PERFORM processing.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  PROCESSING
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM processing .

  DATA: lt_bkpf  TYPE gtyt_bkpf.
  DATA: ls_bkpf  TYPE gtys_bkpf.
  DATA: lt_bseg  TYPE gtyt_bseg.
  DATA: ls_bseg  TYPE gtys_bseg.

* Die Datentabellen sind in diesem Beispiel nicht gef√ºllt
* Im beiliegenden PDF sind exemplarisch einige Buchungss√§tze zusammengestellt,
* welche aber nur f√ºr das System g√ºltig sind, in dem Sie verbucht wurden.
* Um das Beispiel nutzen zu k√∂nnen, m√º√üt ihr hier die Daten entsprechend
* Eurem System von Hand aufbauen
* Das Buchungsdatum habe ich leer gelassen, da in diesem Beispiel immer mit dem
* aktuellen Tagesdatum gebucht wird.
* Die Felder GJAHR und POPER werden w√§hrend des Programmlaufes ermittelt
* und dann in die LS_BKPF √ºbertragen - f√ºr den Fall, das man das ganze
* als Vorlage f√ºr eine Schnittstelle laufen lassen will ;-)
*
* F√ºr die Standardbuchung habe ich den Buchungssatz hier ausgesternt schon
* einmal vorbereitet:
*  CLEAR ls_bkpf.
*  ls_bkpf-id    = '1'.
*  ls_bkpf-budat = '00000000'.
*  ls_bkpf-bldat = '20180611'.
*  ls_bkpf-bukrs = '1000'.
*  ls_bkpf-gjahr = '0000'.
*  ls_bkpf-poper = '000'.
*  ls_bkpf-xblnr = '123'.
*  ls_bkpf-waers = 'EUR'.
*  APPEND ls_bkpf TO lt_bkpf.
*
*  CLEAR ls_bseg.
*  ls_bseg-id    = '1'.
*  ls_bseg-buzei = '001'
*  ls_bseg-koart = 'K'.
*  ls_bseg-shgkz = 'H'.
*  ls_bseg-gkont = '0000100205'.
*  ls_bseg-mwskz = abap_false.
*  ls_bseg-brutto = '1725.00'.
*  ls_bkpf-landl = 'DE'.
*  ls_bkpf-lzbkz = abap_false. "kein Nicht Deutscher Kreditor
*  APPEND ls_bseg TO lt_bseg.
*
*  CLEAR ls_bseg.
*  ls_bseg-id    = '1'.
*  ls_bseg-buzei = '002'.
*  ls_bseg-koart = 'S'.
*  ls_bseg-shgkz = 'S'.
*  ls_bseg-gkont = '0000479100'.
*  ls_bseg-mwskz = 'V3'.
*  ls_bseg-netto = '500.00'.
*  ls_bseg-kostl = '0000000100'.
*  ls_bseg-aufnr  = space.
*  ls_bseg-vbeln  = space.
*  ls_bseg-posnr  = '000000'.
*  ls_bseg-anln1  = space.
*  ls_bseg-anln2 = space.
*  ls_bseg-bwasl = space.
*  APPEND ls_besg TO lt_bseg.
*
*  CLEAR ls_bseg.
*  ls_bseg-id    = '1'.
*  ls_bseg-buzei = '003'.
*  ls_bseg-koart = 'S'.
*  ls_bseg-shgkz = 'S'.
*  ls_bseg-gkont = '0000479100'.
*  ls_bseg-mwskz = 'V2'.
*  ls_bseg-netto = '500.00'.
*  ls_bseg-kostl = '0000000100'.
*  ls_bseg-aufnr  = space.
*  ls_bseg-vbeln  = space.
*  ls_bseg-posnr  = '000000'.
*  ls_bseg-anln1  = space.
*  ls_bseg-anln2 = space.
*  ls_bseg-bwasl = space.
*  APPEND ls_besg TO lt_bseg.
*
*  CLEAR ls_bseg.
*  ls_bseg-id    = '1'.
*  ls_bseg-buzei = '004'.
*  ls_bseg-koart = 'S'.
*  ls_bseg-shgkz = 'S'.
*  ls_bseg-gkont = '0000479100'.
*  ls_bseg-mwskz = 'V3'.
*  ls_bseg-netto = '500.00'.
*  ls_bseg-kostl = '0000000140'.
*  ls_bseg-aufnr  = space.
*  ls_bseg-vbeln  = space.
*  ls_bseg-posnr  = '000000'.
*  ls_bseg-anln1  = space.
*  ls_bseg-anln2 = space.
*  ls_bseg-bwasl = space.
*  APPEND ls_besg TO lt_bseg.

  LOOP AT lt_bkpf INTO ls_bkpf.

    PERFORM post_acc_doc USING ls_bkpf
                               lt_bseg.
  ENDLOOP.

ENDFORM.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  POST_ACC_DOC
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM post_acc_doc USING pis_bkpf  TYPE gtys_bkpf
                        pit_bseg  TYPE gtyt_bseg.

  DATA: ls_bkpf   TYPE gtys_bkpf.
  DATA: lt_bseg   TYPE gtyt_bseg.
  DATA: ls_bseg   TYPE gtys_bseg.
  DATA: lt_tax    TYPE gtyt_tax.

  DATA: BEGIN OF ls_awkey,
          belnr TYPE bkpf-belnr,
          bukrs TYPE bkpf-bukrs,
          gjahr TYPE bkpf-gjahr,
        END OF ls_awkey.

  DATA: lv_buzei TYPE bseg-buzei.
  DATA: lv_tabix TYPE sy-tabix.
  DATA: lv_subrc TYPE sy-subrc.
  DATA: lv_exit  TYPE xfeld.

* BAPI-Definitionen
* BKPF
  DATA ls_header TYPE bapiache09.
* BAPI-Protokoll
  DATA lt_return TYPE bapiret2_tab.
  DATA ls_return TYPE bapiret2.
* Sachkontenzeile
  DATA lt_acc_gl TYPE bapiacgl09_tab.
* Kreditorenzeile
  DATA lt_acc_py TYPE bapiacap09_tab.
* Debitorenzeile - Im Beispiel nicht ausgef√ºhrt
  DATA lt_acc_rv TYPE bapiacar09_tab               ##NEEDED.
* Wertzeile
  DATA lt_cur_am TYPE bapiaccr09_tab.
* Steuerzeile
  DATA lt_acc_tx TYPE bapiactx09_tab.
* Zus√§tzliche Parameter (siehe Routine add_cred_line)
  DATA lt_ext2   TYPE tt_bapiparex.
* CO-PA Merkmalstabelle
  DATA lt_acc_crit  TYPE bapiackec9_tab.
* CO-PA Wertetabelle
  DATA lt_acc_value TYPE bapiackev9_tab.

  ls_bkpf = pis_bkpf.

* Kopfdaten aufbereiten
  PERFORM add_head_line CHANGING ls_bkpf
                                 ls_header.

* Loop √ºber alle Buchungszeilen des Beleges
  LOOP AT pit_bseg INTO ls_bseg
    WHERE id EQ ls_bkpf-id.
    lv_tabix = sy-tabix.
*   Kopieren der aktuellen Buchungszeile
*   Brauchen wir sp√§ter, wenn wir die Steuerzeilen erzeugen wollen
    lv_buzei = ls_bseg-buzei.

*   Unterscheidung nach Kontoart
    CASE ls_bseg-koart.
*     Debitorenzeile
      WHEN 'D'.
*       Behandeln wir hier nicht - ist aber analog zum Kreditoren

*     Kreditorenzeile
      WHEN 'K'.
*       Kreditorenzeile aufbauen
        PERFORM add_cred_line USING    pis_bkpf
                                       ls_bseg
                              CHANGING lt_acc_py
                                       lt_ext2.

*       Betragszeile
        PERFORM add_curr_line USING    pis_bkpf
                                       ls_bseg
                                       lv_tabix
                              CHANGING lt_cur_am.
      WHEN 'S'.
*       Sachkontenzeile
        PERFORM add_sach_line USING    ls_bkpf
                                       ls_bseg
                              CHANGING lt_acc_gl
                                       lt_acc_crit
                                       lt_acc_value
                                       lt_ext2
                                       lv_subrc.
        IF lv_subrc NE 0.
          lv_exit = abap_true.
          EXIT.
        ENDIF.

*       Betragszeile
        PERFORM add_curr_line USING    pis_bkpf
                                       ls_bseg
                                       lv_tabix
                              CHANGING lt_cur_am.

*       Steuer f√ºr Sachkontenpositionszeilen ermitteln
        PERFORM get_tax USING    pis_bkpf
                                 ls_bseg
                                 lv_tabix
                        CHANGING lt_tax.

    ENDCASE.
  ENDLOOP.

* Fehler bei der CO-PA Ermittlung - und raus
  IF lv_exit EQ abap_true.
    RETURN.
  ENDIF.

* Nachdem wir auf den Sachkontenzeilen alle Steuern
* gesammelt haben, bauen wir daraus jetzt die Steuerzeilen auf
  PERFORM add_tax_lines USING    lt_tax
                                 pis_bkpf
                                 lv_buzei
                        CHANGING lt_acc_tx
                                 lt_cur_am.

* Beleg pr√ºfen
  CALL FUNCTION 'BAPI_ACC_DOCUMENT_CHECK'
    EXPORTING
      documentheader = ls_header
    TABLES
      accountgl      = lt_acc_gl
      accountpayable = lt_acc_py
      accounttax     = lt_acc_tx
      currencyamount = lt_cur_am
      extension2     = lt_ext2
      return         = lt_return.
* Protokoll auswerten
  READ TABLE lt_return INTO ls_return
    WITH KEY type   = 'S'
             id     = 'RW'
             number = '614'.
  IF sy-subrc EQ 0.
*   Testflag abfragen
*   Wenn gesetzt, raus
    IF NOT p_xtest IS INITIAL.
      FORMAT COLOR COL_POSITIVE.
      WRITE:/ 'ID', pis_bkpf-id,
            'erfolgreich gebucht'                       ##NO_TEXT.
      FORMAT COLOR OFF.
      RETURN.
    ENDIF.
*   Kein Testflag. Buchen
    FREE lt_return.
    CALL FUNCTION 'BAPI_ACC_DOCUMENT_POST'
      EXPORTING
        documentheader = ls_header
      TABLES
        accountgl      = lt_acc_gl
        accountpayable = lt_acc_py
        accounttax     = lt_acc_tx
        currencyamount = lt_cur_am
        extension2     = lt_ext2
        return         = lt_return.
    READ TABLE lt_return INTO ls_return
      WITH KEY type   = 'S'
               id     = 'RW'
               number = '605'.
    IF sy-subrc EQ 0.
      MOVE ls_return-message_v2 TO ls_awkey.
*     Commit Work durchf√ºhren
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        IMPORTING
          return = ls_return.
      IF NOT ls_return IS INITIAL.
      ELSE.
        FORMAT COLOR COL_POSITIVE.
        WRITE:/ 'ID', pis_bkpf-id,
                'erfolgreich gebucht'                  ##NO_TEXT.
        FORMAT COLOR OFF.
        WRITE:/ 'Beleg'                                ##NO_TEXT,
                pis_bkpf-id,
                ls_awkey-bukrs,
                ls_awkey-belnr,
                ls_awkey-gjahr,
                'erfolgreich gebucht'                  ##NO_TEXT.
      ENDIF.
    ELSE.
      FORMAT COLOR COL_NEGATIVE.
      WRITE: /'ID', pis_bkpf-id, 'fehlerhaft'          ##NO_TEXT.
      FORMAT COLOR OFF.
      LOOP AT lt_return INTO ls_return
      WHERE type NE 'S'
      AND   type NE 'I'.
        IF ls_return-id     EQ 'RW' AND
           ls_return-number EQ '609'.
          CONTINUE.
        ENDIF.
        WRITE: / pis_bkpf-id,
                 ls_return-row,
                 ls_return-type,
                 ls_return-id,
                 ls_return-number,
                 ls_return-message.
      ENDLOOP.
    ENDIF.
* Fehler bei der Belegpr√ºfung
  ELSE.
    FORMAT COLOR COL_NEGATIVE.
    WRITE: /'ID', pis_bkpf-id, 'fehlerhaft'            ##NO_TEXT.
    FORMAT COLOR OFF.
    LOOP AT lt_return INTO ls_return
    WHERE type NE 'S'
    AND   type NE 'I'.
      IF ls_return-id EQ 'RW' AND
       ls_return-number EQ '609'.
        CONTINUE.
      ENDIF.
      WRITE:/ pis_bkpf-id,
              ls_return-row,
              ls_return-type,
              ls_return-id,
              ls_return-number,
              ls_return-message.
    ENDLOOP.
  ENDIF.

ENDFORM.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ADD_HEAD_LINE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM add_head_line  CHANGING pcs_bkpf   TYPE gtys_bkpf
                             pes_header TYPE bapiache09.

  CLEAR pes_header.

  DATA: ls_header TYPE bapiache09.

  ls_header-bus_act           = 'RFBU'.               "Betriebswirtschaftlicher Vorgang
  ls_header-username          = sy-uname.             "Name des Benutzers
  ls_header-header_txt        = pcs_bkpf-bktxt.       "Belegkopftext
  ls_header-comp_code         = pcs_bkpf-bukrs.       "Buchungskreis
  ls_header-doc_date          = pcs_bkpf-bldat.       "Belegdatum

* Ermitteln von Gesch√§ftsjahr und Periode aus dem Buchungsdatum
* In unserem Fall ist das Buchungsdatum leer, also nehmen wir das
* Tagesdatum. Es kann aber auch ein bestimmtes Datum √ºbergeben werden
* Dann aber darauf achten, das die entsprechenden Perioden zum
* Buchen offen sind
  PERFORM add_data_to_bkpf CHANGING pcs_bkpf.
  IF pcs_bkpf-budat IS INITIAL.
    ls_header-pstng_date      = sy-datum.             "Buchungsdatum
  ELSE.
    ls_header-pstng_date      = pcs_bkpf-budat.     "Buchungsdatum
  ENDIF.

  ls_header-trans_date        = sy-datum.             "Umrechnungsdatum
  ls_header-fisc_year         = pcs_bkpf-gjahr.       "Gesch√§ftsjahr
  ls_header-fis_period        = pcs_bkpf-poper.       "Gesch√§ftsmonat
  ls_header-doc_type          = pcs_bkpf-blart.       "Belegart
  ls_header-ref_doc_no        = pcs_bkpf-xblnr.       "Referenznummer

* Achtung !!!!
* Entweder Umrechnungsdatum oder Kurs - nicht beides mitgeben !!!!!
  IF NOT pcs_bkpf-wwert IS INITIAL.
    ls_header-trans_date    = pcs_bkpf-wwert.
  ENDIF.

* Sollten zus√§tzliche Werte ben√∂tigt werden, hier √ºbergeben
* oder die Kopftabelle entsprechend "aufbohren".

  pes_header = ls_header.

ENDFORM.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ADD_DATA_TO_BKPF
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM add_data_to_bkpf CHANGING pcs_bkpf TYPE gtys_bkpf.

  TYPES: BEGIN OF ltys_t001,
           bukrs TYPE t001-bukrs,
           periv TYPE t001-periv,
         END OF ltys_t001,
         ltyt_t001 TYPE HASHED TABLE OF ltys_t001 WITH UNIQUE KEY bukrs.

  STATICS: lv_first_call TYPE xfeld.
  STATICS: lt_t001       TYPE ltyt_t001.
  DATA: ls_t001 TYPE ltys_t001.
  DATA: lv_buper TYPE poper.
  DATA: lv_gjahr TYPE gjahr.
  DATA: lv_budat TYPE bkpf-budat.

* Ermittlung der Gesch√§ftsjahresvariante f√ºr alle im System vorhandenen
* Buchungskreise
  IF lv_first_call IS INITIAL.
    SELECT bukrs periv
           FROM t001
           INTO TABLE lt_t001.
    MOVE abap_true TO lv_first_call.
  ENDIF.

  READ TABLE lt_t001 INTO ls_t001
    WITH TABLE KEY bukrs = pcs_bkpf-bukrs.
  IF sy-subrc EQ 0.
    IF pcs_bkpf-budat IS INITIAL.
      MOVE sy-datum       TO lv_budat.
    ELSE.
      MOVE pcs_bkpf-budat TO lv_budat.
    ENDIF.

*   Ermittlung der Periode und des Gesch√§ftsjahres
*   anhand des Buchungsdatum und der Gesch√§ftsjahresvariante
*   (Stichwort: Verschobenes Gesch√§ftsjahr)
    CALL FUNCTION 'DATE_TO_PERIOD_CONVERT'
      EXPORTING
        i_date         = lv_budat
        i_periv        = ls_t001-periv
      IMPORTING
        e_buper        = lv_buper
        e_gjahr        = lv_gjahr
      EXCEPTIONS
        input_false    = 1
        t009_notfound  = 2
        t009b_notfound = 3
        OTHERS         = 4.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE 'E' NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    MOVE: lv_buper TO pcs_bkpf-poper,
          lv_gjahr TO pcs_bkpf-gjahr.
  ELSE.
*   Fehlermeldung - darf nicht vorkommen !!!!
*   Buchungskreis &amp;1 ist nicht vorhanden
    MESSAGE a215(fagl_emu) WITH pcs_bkpf-bukrs.
  ENDIF.

ENDFORM.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ADD_CRED_LINE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM add_cred_line  USING    pis_bkpf TYPE gtys_bkpf
                             pis_bseg TYPE gtys_bseg
                    CHANGING pct_cred TYPE bapiacap09_tab
                             pct_ext2 TYPE tt_bapiparex.

  DATA: ls_struc_ext2 TYPE zsc_s_soawf_badi_acc_doc.
  DATA: ls_cred  LIKE LINE OF pct_cred.
  DATA: ls_ext2  LIKE LINE OF pct_ext2.

* Kreditorenzeile
  ls_cred-itemno_acc        = pis_bseg-buzei.       "Positionsnummer des Rechnungswesenbeleges
  ls_cred-vendor_no         = pis_bseg-gkont.       "Lieferantennummer
* Das Sachkonto auf welches gebucht wird, ist immer das im Lieferantenstamm
* eingetragene Abstimmkonto
* Gilt √ºbrigens auch f√ºr Debitoren. Dort ist es AKONT in der KNB1
  SELECT SINGLE akont
                FROM lfb1
                INTO ls_cred-gl_account
                WHERE lifnr EQ pis_bseg-gkont
                AND   bukrs EQ pis_bkpf-bukrs.
  ls_cred-item_text         = pis_bseg-sgtxt.       "Positionstext
  ls_cred-supcountry        = pis_bseg-landl.       "Lieferland wenn nicht DE

* Schmankerl 1
* √úbergabe eines nicht in der Kreditorenstruktur vorhandenen Feldes - in diesem
* Falle das Landeszentralbankkennzeichen
  IF NOT pis_bseg-lzbkz IS INITIAL.
*   Hierzu MUSS!! man sich im DDIC eine Struktur definieren, welche
*   all die Felder enth√§lt, welche man zus√§tzlich √ºbergeben will.
*   Diese wird im Feld STRUCTURE der Struktur BAPIPAREX √ºbergeben.
*
*   Als Maximalmenge k√∂nnen die Felder der Struktur ACCIT √ºbergeben werden.
*   Die Struktur MUSS!!! immer ein Feld vom Typen
*   POSNR TYPE POSNR_ACC
*   enthalten. Dieser stellt die Verbindung von der √úbergabezeile (in diesem Falle
*   der Kreditorenzeile) zur Extension2-Zeile her.
*
*   Als weitere Felder werden dann die zu zus√§tzlich ben√∂tigten Felder √ºbergeben.
*
*   Um nun die Felder auch ins BAPI zu bringen, mu√ü man zum BADI ACC_DOCUMENT
*   mit der SE19 eine eigene Implementierung anlegen (oder, wenn Gl√ºck hat, ist
*   bereits eine vorhanden).
*   Hierzu MUSS!!! man den Filterwert auf BKPFF (nicht BKPF) stellen, da dieser
*   vom BAPI gefordert bzw. geschrieben wird.
*   Als Coding kann man das Coding der Beispielimplementierung der SAP nutzen, welche man
*   aus der Beispielimplementierung in die eigene Implementierung kopiert.
*   ACHTUNG!!!!!!
*   Nicht den Fehler machen und die ACCIT als Strukturnamen und √úbergabestruktur
*   benutzen. Die Felder VALUEPART1 bis VALUEPART4 werden concateniert und sind
*   insgesamt nur 960 Zeichen lang !!! Da kann man mit der ACCIT und Ihren 496 Feldern!
*   auch schon mal ganz schnell ins Klo greifen, wenn die Felder erst hinter
*   den 960 Zeichen aufgerufen werden.
*   Wenn man mehr als 240 Zeichen √úbergabe ben√∂tigt, ein Charakterfeld mit 960 Zeichen
*   definieren, die Struktur darauf moven, dann zerhaken und als VALUEPART1 bis 4 √ºbergeben.
*   ACHTUNG !!!!
*   Bei √úbergabe von Zahlfeldern diese vorher in Charakterwerte umwandeln und dann √ºbergeben,
*   sonst geht es schief. Ggf. die Implentierung entsprechend anpassen.
*   ACHTUNG !!!
*   Da die √úbergabefelder CHAR-Werte sind, kann Kleinschreibung nicht √ºbergeben werden.
*   Danke SAP!!!
    MOVE 'Z_BADI_ACC_DOC' TO ls_ext2-structure.
    ls_struc_ext2-posnr = pis_bseg-buzei.
    ls_struc_ext2-lzbkz = pis_bseg-lzbkz.
    MOVE ls_struc_ext2 TO ls_ext2-valuepart1.
    APPEND ls_ext2 TO pct_ext2.
  ENDIF.

  APPEND ls_cred TO pct_cred.

ENDFORM.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ADD_CURR_LINE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM add_curr_line  USING    pis_bkpf   TYPE gtys_bkpf
                             pis_bseg   TYPE gtys_bseg
                             piv_tabix  TYPE sy-tabix
                    CHANGING pet_curr   TYPE bapiaccr09_tab.

  DATA: ls_curr   LIKE LINE OF pet_curr.
  DATA: lv_amount TYPE bseg-wrbtr.

  CASE pis_bseg-koart.
*   Kreditorische/Debitorische Zeilen nur einmal im Beleg
*   als Kopfzeile - daher immer Brutto!!
    WHEN 'K' OR 'D'.
      MOVE pis_bseg-brutto TO lv_amount.
    WHEN 'S'.
*     Bei Sachkontenbuchungen Unterscheidung
*     nach Kopf- und Positionszeilen
      IF piv_tabix EQ 1.
        MOVE pis_bseg-brutto TO lv_amount.
      ELSE.
        MOVE pis_bseg-netto  TO lv_amount.
      ENDIF.
  ENDCASE.

* Habenwerte immer mit -1 multiplizieren (braucht das BAPI
* um zu erkennen, was es buchen soll)
  CASE pis_bseg-shkzg.
    WHEN 'H'.
      lv_amount = lv_amount * -1.
  ENDCASE.

  ls_curr-itemno_acc        = pis_bseg-buzei.
  ls_curr-currency          = pis_bkpf-waers.
* Wenn die W√§hrung nicht stimmen sollte, hier umwandeln
  ls_curr-currency_iso      = pis_bkpf-waers.
  ls_curr-amt_doccur        = lv_amount.
* W√§hrungstyp
* Hier steht die Belegw√§hrung, was der Standardfall ist.
* Sollen zus√§tzlich andere Typen verwendet werden, m√º√üen die Werte angepa√üt
* werden. Aber das ist ein ganz eigenes Kapitel. Werde ich ggf. bei
* Zeiten erg√§nzen.
  ls_curr-curr_type         = '00'.
* Umrechnungskurs f√ºr Fremdw√§hrung
* ACHTUNG!!!
* Entweder hier KURSF ODER!!!! im Kopf WWERT mitgeben
  ls_curr-exch_rate         = pis_bkpf-kursf.

  APPEND ls_curr TO pet_curr.

ENDFORM.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ADD_SACH_LINE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM add_sach_line  USING    pis_bkpf  TYPE gtys_bkpf
                             pis_bseg  TYPE gtys_bseg
                    CHANGING pct_sach  TYPE bapiacgl09_tab
                             pct_crit  TYPE bapiackec9_tab
                             pct_value TYPE bapiackev9_tab
                             pct_ext2  TYPE tt_bapiparex
                             pev_subrc TYPE sy-subrc.

  DATA: ls_struc_ext2 TYPE zsc_s_soawf_badi_acc_doc.
  DATA: ls_ext2       LIKE LINE OF pct_ext2.
  DATA: ls_acc_gl     LIKE LINE OF pct_sach.
  DATA: lv_subrc      TYPE sy-subrc.

  CLEAR pev_subrc.

  ls_acc_gl-itemno_acc        = pis_bseg-buzei.       "Positionsnummer des Rechnungswesenbeleges
  ls_acc_gl-gl_account        = pis_bseg-gkont.       "Sachkonto der Hauptbuchhaltung
  ls_acc_gl-item_text         = pis_bseg-sgtxt.       "Positionstext
  ls_acc_gl-acct_key          = space.                "Vorgangsschl√ºssel
* Bei Kontierung Kreditor auf Anlage mu√ü die Kontoart auf 'A'
* wie Anlage umgestellt werden.
* Ferner brauchen wir das Abstimmkonto der Anlage
* und wir m√ºssen, √ºber die Externen Felder, die Bewegungsart
* mitgeben. Andernfalls bekommen wir keine Anlagenbuchung
  IF NOT pis_bseg-anln1 IS INITIAL.
    ls_acc_gl-acct_type         = 'A'.                "Kontoart
    ls_acc_gl-gl_account        = pis_bseg-gkont.     "Sachkonto der Hauptbuchhaltung
    ls_acc_gl-acct_key          = 'ANL'.              "Vorgangsschl√ºssel f√ºr Anlagenbuchungen (BSCHL 70/75)
    MOVE 'ZSC_S_SOAWF_BADI_ACC_DOC' TO ls_ext2-structure.
    ls_struc_ext2-posnr = pis_bseg-buzei.
    ls_struc_ext2-anbwa = '100'.
    MOVE ls_struc_ext2 TO ls_ext2-valuepart1.
    APPEND ls_ext2 TO pct_ext2.
  ELSE.
    ls_acc_gl-acct_type         = 'S'.                "Kontoart
    ls_acc_gl-gl_account        = pis_bseg-gkont.     "Sachkonto der Hauptbuchhaltung
  ENDIF.

  ls_acc_gl-acct_type         = pis_bseg-koart.       "Kontoart
  ls_acc_gl-tax_code          = pis_bseg-mwskz.       "Mehrwertsteuerkennzeichen
* Standardkontierungen, ggf. erg√§nzen.
  ls_acc_gl-costcenter        = pis_bseg-kostl.       "Kostenstelle
  ls_acc_gl-orderid           = pis_bseg-aufnr.       "Innenauftrag
  ls_acc_gl-asset_no          = pis_bseg-anln1.       "Anlagenhauptnummer
  ls_acc_gl-sub_number        = pis_bseg-anln2.       "Anlagenunternummer

  IF NOT pis_bseg-vbeln IS INITIAL.
    PERFORM add_copa_line USING    pis_bkpf
                                   pis_bseg
                          CHANGING pct_crit
                                   pct_value
                                   lv_subrc.
    IF sy-subrc NE 0.
      pev_subrc = 4.
      RETURN.
    ENDIF.
  ENDIF.

  APPEND ls_acc_gl TO pct_sach.

ENDFORM.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ADD_COPA_LINE
*&amp;---------------------------------------------------------------------*
*       Schmankerl CO-PA Kontierung
*       Dem BAPI ACC_DOCUMENT_POST m√ºssen die Merkmals- sowie die
*       Wertedaten f√ºr die CO-PA Kontierung mitgegeben werden
*       Hierbei kommt es vor, das von Kundenseite oder der Schnittstellt
*       nur der Kundenauftrag zur Verf√ºgung gestellt wird und die
*       CO-PA Kontierungen dem Programmierer "√ºberlassen" werden.
*       Danke f√ºr die Info ;-)
*       Was tun?
*       Zum Gl√ºck f√ºr uns gibt es den Report RFBIBL00 bzw RFBBIBL01
*       der ebenfalls mit CO-PA Daten best√ºckt werden kann.
*       Hierf√ºr gibt es den Baustein RKE_CONVERT_CRITERIA_PAOBJNR
*       der aus gegegbenen Daten eine neu CO-PA Ableitung f√§hrt
*       aus der man dann die Merkmale nachlesen und dem BAPI unterschieben kann.
******  ACHTUNG !!!!!! ***********
*       Das neue Kontierungsobjekt wird nur dann weggeschrieben und
*       kann nachgelesen werden, wenn ein COMMIT WORK erfolgt!!!!
*       Das ist zwar unsch√∂n aber ich kenne keine andere Methode um an eine
*       komplette Ableitung zu gelangen. Wenn jemand eine kennt, w√§re
*       ich dankbar, wenn diese √∂ffentlich gemacht w√ºrde.
*       Man mu√ü also aufpassen, das man vorher keine Daten auf der
*       Datenbank bereits ge√§ndert oder angelegt hat. Diese w√ºrde
*       hier unweigerlich commited!!!!!
*
*       Das ist aber leider nur die H√§lfte der Wahrheit
*       Wir brauchen leider nicht nur die Merkmale, sondern wir m√ºssen
*       ja auch noch die WErtfelder best√ºcken.
*       Hierzu siehe Routine ADD_VALUE_LINE
*
*       Und als ob das noch nicht reichen w√ºrde, m√ºssen wir die erhaltene
*       Ableitung auch noch durch eine Routine schicken, welche die
*       alle relevanten Konvertierungsexits durchl√§uft, weil der
*       Ableitungsbaustein nur die externe Darstellung (RFBIBL -&gt; BI-Programm)
*       zur√ºckliefert aber nicht die interne, welche das BAPI fordert.
*       Hierzu siehe Routine 'CHANGE_DATA_CONV_EXIT
*       Diese Routine kann man in abgewandelter Form auch benutzen, um
*       z.B. Datenbankdaten f√ºr einen Batch-Input aufzubereiten (z.B.
*       Arbeitspl√§tze oder PSP-Elemente).
*----------------------------------------------------------------------*
FORM add_copa_line  USING    pis_bkpf  TYPE gtys_bkpf
                             pis_bseg  TYPE gtys_bseg
                    CHANGING pct_crit  TYPE bapiackec9_tab
                             pct_value TYPE bapiackev9_tab
                             pev_subrc TYPE sy-subrc.

  DATA: ls_copabbseg TYPE copabbseg.
  DATA: ls_crit      LIKE LINE OF pct_crit.
  DATA: lv_paobjnr   TYPE rkeobjnr.
  DATA: lv_subrc     TYPE sy-subrc.
  DATA: lt_copadata  TYPE gtyt_copadata.
  DATA: ls_copadata  LIKE LINE OF lt_copadata.
  DATA: ls_org_copa  TYPE gtys_org_copa.

  CLEAR pev_subrc.

  IF pis_bseg-vbeln IS INITIAL.
    RETURN.
  ENDIF.

* Zuordnung BURKS zu KOKRS/ERKRS ermitteln
  PERFORM get_orgdata_copa USING    pis_bkpf-bukrs
                           CHANGING ls_org_copa.

* Wertfeldtabelle f√ºllen
  PERFORM add_value_line USING    pis_bkpf
                                  pis_bseg
                                  ls_org_copa-kokrs
                                  ls_org_copa-erkrs
                         CHANGING pct_value
                                  lv_subrc.
  IF lv_subrc NE 0.
    pev_subrc = 4.
    RETURN.
  ENDIF.

* √úbergabe f√ºr Baustein f√ºttern
* Buchungskreis MUSS zwingend gef√ºllt werden
  MOVE: pis_bkpf-bukrs TO ls_copabbseg-rke_bukrs.
  MOVE: pis_bseg-vbeln TO ls_copabbseg-rke_kaufn.
  MOVE: pis_bseg-posnr TO ls_copabbseg-rke_kdpos.

* Neue Ableitung
  CALL FUNCTION 'RKE_CONVERT_CRITERIA_PAOBJNR'
    EXPORTING
      is_copabbseg     = ls_copabbseg
*     i_date           =
    IMPORTING
      e_paobjnr        = lv_paobjnr
    EXCEPTIONS
      no_bukrs_found   = 1
      no_erkrs_found   = 2
      error_criterion  = 3
      error_derivation = 4
      OTHERS           = 5.
  IF sy-subrc &lt;&gt; 0.
*   Fehler bei Ableitung CO-PA Merkmale f√ºr ID &amp; Buzei &amp;.
    pev_subrc = 4.
    RETURN.
  ENDIF.

* Commit Work durchf√ºhren, damit die Ergebnisobjektnummer auf
* der Datenbank vorliegt
  COMMIT WORK  AND WAIT.
  IF sy-subrc NE 0.
*   Fehler bei der Fortschreibung PAOBJNR f√ºr ID &amp; Buzei &amp;.
    pev_subrc = 4.
    RETURN.
  ENDIF.

* Nachlesen der neuen Ableitung
  CALL FUNCTION 'RKE_CONVERT_PAOBJNR_COPADATA'
    EXPORTING
      bukrs          = pis_bkpf-bukrs
      kokrs          = ls_org_copa-kokrs
      paobjnr        = lv_paobjnr
    TABLES
      i_copadata     = lt_copadata
    EXCEPTIONS
      no_erkrs_found = 1
      paobjnr_wrong  = 2
      OTHERS         = 3.
  IF sy-subrc &lt;&gt; 0.
*   Fehler bei Ermittlung Wertfelder aus PAOBJNR f√ºr ID &amp; Buzei &amp;.
    pev_subrc = 4.
    RETURN.
  ENDIF.

* Umstellung der externen Darstellung der Merkmale auf
* interne Werte (durchlaufen der Konvertierungsexits)
  IF NOT lt_copadata IS INITIAL.
    PERFORM change_data_conv_exit USING    ls_org_copa-erkrs
                                  CHANGING lt_copadata.
  ENDIF.

* Anh√§ngen der Merkmale an die Merkmalstabelle f√ºr das BAPI
  LOOP AT lt_copadata INTO ls_copadata.
    IF NOT ls_copadata-fval IS INITIAL.
      CLEAR ls_crit.

      MOVE: pis_bseg-buzei   TO ls_crit-itemno_acc,
            ls_copadata-fnam TO ls_crit-fieldname,
            ls_copadata-fval TO ls_crit-character.
      APPEND ls_crit TO pct_crit.
    ENDIF.
  ENDLOOP.

ENDFORM.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_ORGDATA_COPA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_orgdata_copa  USING    piv_bukrs    TYPE bukrs
                       CHANGING pes_org_copa TYPE gtys_org_copa.

  CLEAR pes_org_copa.

  DATA: ls_org_copa    LIKE pes_org_copa.
  DATA: lv_kokrs       TYPE kokrs.
  DATA: lv_erkrs       TYPE erkrs.
  STATICS: lt_org_copa TYPE gtyt_org_copa_hash.

  READ TABLE lt_org_copa INTO ls_org_copa
    WITH TABLE KEY bukrs = piv_bukrs.
  IF sy-subrc EQ 0.
    pes_org_copa = ls_org_copa.
    RETURN.
  ENDIF.

  CALL FUNCTION 'KOKRS_GET_FROM_BUKRS'
    EXPORTING
      i_bukrs        = piv_bukrs
    IMPORTING
      e_kokrs        = lv_kokrs
    EXCEPTIONS
      no_kokrs_found = 1
      OTHERS         = 2.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE 'E' NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

  CALL FUNCTION 'COPA_ERKRS_FIND'
    EXPORTING
      bukrs              = piv_bukrs
    IMPORTING
      erkrs              = lv_erkrs
    EXCEPTIONS
      error_kokrs_find   = 1
      kokrs_wrong        = 2
      no_erkrs_defined   = 3
      no_erkrs_for_kokrs = 4
      OTHERS             = 5.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE 'E' NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

  MOVE: piv_bukrs TO ls_org_copa-bukrs,
        lv_kokrs  TO ls_org_copa-kokrs,
        lv_erkrs  TO ls_org_copa-erkrs.
  INSERT ls_org_copa INTO TABLE lt_org_copa.
  pes_org_copa = ls_org_copa.

ENDFORM.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ADD_VALUE_LINE
*&amp;---------------------------------------------------------------------*
*       Das BAPI fordert von uns nicht nur die Merkmale sondern wir
*       m√ºssen auch die Wertfelder best√ºcken - und zwar die richtigen!!!
*
*       Die erreichen wir, indem wir den Baustein
*       COPA_GET_SETTLEMENT_STRUCTURE benutzen. Dieser gibt uns
*       das Ergebnisschmema, die Zuordnung sowie den Inhalt der Tabelle
*       TKB9F zur√ºck.
*       Hierzu mu√ü man wissen, das f√ºr das Konto, auf welches gebucht
*       werden soll, im Customizing hinterlegt sein MUSS, auf welches
*       Wertfeld die Betr√§ge laufen sollen.
*       Also lesen wir zun√§chst mit dem Baustein Schema und Zuordnung
*       und dann damit die Tabelle.
*       Nicht wundern, das hier bestimmte Werte hart verdrahtet sind.
*       Das ist so und mu√ü auch so gecustomized sein.
*       Es MUSS ein Wertfeld sein (MWKZ = 1) und das Fix-/Variabel Kz.
*       MUSS auf Gesamtwert (FVKZ = 3) stehen. Ist das nicht der Fall,
*       ist dies ein Fehler!!!!
*       Hat man vor mehrere Belege f√ºr unterschiedliche W√§hrungs-
*       sichten zu erzeugen, so mu√ü man dies auch hier tun. Im diesem
*       Beispiel nehmen wir nur die Belegw√§hrung
*----------------------------------------------------------------------*
FORM add_value_line USING    pis_bkpf  TYPE gtys_bkpf
                             pis_bseg  TYPE gtys_bseg
                             piv_kokrs TYPE kokrs
                             piv_erkrs TYPE erkrs
                    CHANGING pct_value TYPE bapiackev9_tab
                             pev_subrc TYPE sy-subrc.

  DATA: lt_9f TYPE STANDARD TABLE OF tkb9f.
  DATA: ls_9f LIKE LINE OF lt_9f.
  DATA: lv_ersch TYPE tkb9f-ersch.
  DATA: lv_erzuo TYPE tkb9f-erzuo.

  DATA: ls_value LIKE LINE OF pct_value.
  DATA: BEGIN OF ls_wertfeld,
          hkont  TYPE bseg-hkont,
          wrtfld TYPE fieldname,
        END OF ls_wertfeld.
  STATICS: lt_wertfeld LIKE HASHED TABLE OF ls_wertfeld
                       WITH UNIQUE KEY hkont.

  CLEAR pev_subrc.

* Statische Wertfeldtabelle lesen (damit es schneller geht)
  READ TABLE lt_wertfeld INTO ls_wertfeld
    WITH TABLE KEY hkont = pis_bseg-gkont.
  IF sy-subrc EQ 0.
    MOVE: pis_bseg-buzei     TO ls_value-itemno_acc,
          ls_wertfeld-wrtfld TO ls_value-fieldname,
          '00'               TO ls_value-curr_type,
          pis_bkpf-waers     TO ls_value-currency,
          pis_bkpf-waers     TO ls_value-currency_iso,
          pis_bseg-netto     TO ls_value-amt_valcom.
    APPEND ls_value TO pct_value.
    RETURN.
  ENDIF.

* Ansonsten Ergebnisschema und -zuordnung ermitteln
  CALL FUNCTION 'COPA_GET_SETTLEMENT_STRUCTURE'
    EXPORTING
      i_erkrs              = piv_erkrs
      i_vrgng              = 'RFBU'
      i_hkont              = pis_bseg-gkont
      i_kokrs              = piv_kokrs
    IMPORTING
      e_ersch              = lv_ersch
      e_erzuo              = lv_erzuo
    TABLES
      t_tkb9f              = lt_9f
    EXCEPTIONS
      incomplete_structure = 1
      error_structure      = 2
      OTHERS               = 3.
  IF sy-subrc &lt;&gt; 0.
*   Wertfeld f√ºr Bukrs &amp; Konto &amp; kann nicht ermittelt werden (&amp;).
    pev_subrc = 4.
    RETURN.
  ENDIF.

* TKB9F mit den ermittelten Werten lesen
  READ TABLE lt_9f INTO ls_9f WITH KEY ersch = lv_ersch
                                       erzuo = lv_erzuo
                                       erkrs = piv_erkrs
                                       mwkz  = '1'
                                       fvkz  = '3'.
  IF sy-subrc NE 0.
*   Ist hier nichts zu finden, ist dies ein Fehler und der Beleg
*   w√ºrde sowieso aufbrummen - also Schlu√ü
*   Wertfeld f√ºr Bukrs &amp; Konto &amp; kann nicht ermittelt werden (&amp;)
    pev_subrc = 4.
    RETURN.
  ENDIF.

* Value R√ºckgabetabelle f√ºllen
  MOVE: pis_bseg-buzei TO ls_value-itemno_acc,
        ls_9f-wrtfld   TO ls_value-fieldname,
        '00'           TO ls_value-curr_type,
        pis_bkpf-waers TO ls_value-currency,
        pis_bkpf-waers TO ls_value-currency_iso,
        pis_bseg-netto TO ls_value-amt_valcom.
  APPEND ls_value TO pct_value.

* Und zum Schlu√ü noch die statische Wertfeldtabelle erweitern
  MOVE: pis_bseg-gkont TO ls_wertfeld-hkont,
        ls_9f-wrtfld   TO ls_wertfeld-wrtfld.
  INSERT ls_wertfeld INTO TABLE lt_wertfeld.

ENDFORM.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CHANGE_DATA_CONV_EXIT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM change_data_conv_exit  USING    piv_erkrs TYPE erkrs
                            CHANGING pct_data  TYPE gtyt_copadata.

  DATA: BEGIN OF ls_ddic,
          tabname   TYPE dfies-tabname,
          fieldname TYPE dfies-fieldname,
          rollname  TYPE dfies-rollname,
          convexit  TYPE dfies-convexit,
          funcname  TYPE tfdir-funcname,
          reference TYPE REF TO data,
        END OF ls_ddic,
        lt_ddic LIKE HASHED TABLE OF ls_ddic
                WITH UNIQUE KEY tabname fieldname.
  DATA: lt_ddic_info TYPE ddfields.
  DATA: ls_ddic_info LIKE LINE OF lt_ddic_info.
  DATA: lv_tabname   TYPE tabname.
  DATA: lv_fieldname TYPE fieldname.
  DATA: lv_value     TYPE REF TO data.

  FIELD-SYMBOLS: &lt;ls_data&gt;  LIKE LINE OF pct_data,
                 &lt;lv_value&gt; TYPE any.


  CONCATENATE 'CE0' piv_erkrs INTO lv_tabname.

  LOOP AT pct_data ASSIGNING &lt;ls_data&gt;.
    CHECK NOT &lt;ls_data&gt;-fval IS INITIAL.
    CLEAR: lv_tabname, ls_ddic.

    CONCATENATE 'CE0' piv_erkrs INTO lv_tabname.
    CONDENSE lv_tabname.

    MOVE &lt;ls_data&gt;-fnam TO lv_fieldname.
    READ TABLE lt_ddic INTO ls_ddic
      WITH TABLE KEY tabname   = lv_tabname
                     fieldname = lv_fieldname.
    IF sy-subrc EQ 0.
      IF ls_ddic-funcname IS INITIAL.
        CONTINUE.
      ENDIF.
    ELSE.
      CALL FUNCTION 'DDIF_FIELDINFO_GET'
        EXPORTING
          tabname        = lv_tabname
          fieldname      = lv_fieldname
        TABLES
          dfies_tab      = lt_ddic_info
        EXCEPTIONS
          not_found      = 1
          internal_error = 2
          OTHERS         = 3.
      IF sy-subrc &lt;&gt; 0.
        MESSAGE ID sy-msgid TYPE 'E' NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
      CLEAR ls_ddic.
      READ TABLE lt_ddic_info INTO ls_ddic_info INDEX 1.
      MOVE-CORRESPONDING ls_ddic_info TO ls_ddic.
      IF NOT ls_ddic-convexit IS INITIAL.
        CONCATENATE 'CONVERSION_EXIT_' ls_ddic_info-convexit '_INPUT'
                    INTO ls_ddic-funcname.
        CONDENSE ls_ddic-funcname.
        CREATE DATA lv_value TYPE (ls_ddic-rollname).
        MOVE lv_value TO ls_ddic-reference.
      ENDIF.
      INSERT ls_ddic INTO TABLE lt_ddic.
    ENDIF.
    IF NOT ls_ddic-funcname IS INITIAL.
      ASSIGN ls_ddic-reference-&gt;* TO &lt;lv_value&gt;.
      MOVE &lt;ls_data&gt;-fval TO &lt;lv_value&gt;.
      CALL FUNCTION ls_ddic-funcname
        EXPORTING
          input  = &lt;lv_value&gt;
        IMPORTING
          output = &lt;lv_value&gt;
        EXCEPTIONS
          OTHERS = 0.
      CLEAR &lt;ls_data&gt;-fval.
      MOVE &lt;lv_value&gt; TO &lt;ls_data&gt;-fval.
    ENDIF.
  ENDLOOP.

ENDFORM.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_TAX
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM get_tax  USING    pis_bkpf  TYPE gtys_bkpf
                       pis_bseg  TYPE gtys_bseg
                       piv_tabix TYPE sy-tabix
              CHANGING pct_tax   TYPE gtyt_tax.

  DATA: lv_amount TYPE bseg-wrbtr.
  DATA: lt_mwdat  TYPE STANDARD TABLE OF rtax1u15.
  DATA: ls_mwdat  LIKE LINE OF lt_mwdat.
  DATA: ls_tax    TYPE gtys_tax.
  DATA: lt_tax    TYPE gtyt_tax.

* Nur Steuer auf Positions-, nicht auf Kopfzeilen
  IF piv_tabix EQ 1.
    RETURN.
  ENDIF.

* Steuerkennzeichen mu√ü mitgegeben sein
  IF NOT pis_bseg-mwskz IS INITIAL.
*   ACHTUNG
*   Der Baustein ermittelt die Steuer abh√§ngig vom
*   √ºbergebenen Wert. Da wir mit positiven Werten arbeiten
*   m√ºssen wir hier nat√ºrlich auch ggf. das Vorzeichen drehen
*   sonst geht es schief.
    lv_amount = pis_bseg-netto.
    IF pis_bseg-shkzg EQ 'H'.
      lv_amount = pis_bseg-netto * -1.
    ENDIF.

*   Baustein f√ºr Ermittlung der Steuer aus dem Nettowert
*   Anmerkung: Gibt es auch f√ºr Bruttowerte
*              CALCULATE_TAX_FROM_GROSSAMOUNT
    CALL FUNCTION 'CALCULATE_TAX_FROM_NET_AMOUNT'
      EXPORTING
        i_bukrs           = pis_bkpf-bukrs
        i_mwskz           = pis_bseg-mwskz
        i_waers           = pis_bkpf-waers
        i_wrbtr           = lv_amount
      TABLES
        t_mwdat           = lt_mwdat
      EXCEPTIONS
        bukrs_not_found   = 1
        country_not_found = 2
        mwskz_not_defined = 3
        mwskz_not_valid   = 4
        ktosl_not_found   = 5
        kalsm_not_found   = 6
        parameter_error   = 7
        knumh_not_found   = 8
        kschl_not_found   = 9
        unknown_error     = 10
        account_not_found = 11
        txjcd_not_valid   = 12
        OTHERS            = 13.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE 'E' NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    LOOP AT lt_mwdat INTO ls_mwdat.
      MOVE-CORRESPONDING ls_mwdat TO ls_tax                 ##ENH_OK.
*     Wir brauchen f√ºr die Steuerzeilen aber auch noch das Steuerkenn-
*     zeichen. Daher umkopieren auf eigene Struktur
      MOVE: pis_bseg-mwskz TO ls_tax-mwskz.
      APPEND ls_tax TO lt_tax.
    ENDLOOP.
    IF NOT lt_mwdat IS INITIAL.
      APPEND LINES OF lt_tax TO pct_tax.
    ENDIF.
  ENDIF.

ENDFORM.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ADD_TAX_LINES
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM add_tax_lines  USING    pit_tax    TYPE gtyt_tax
                             pis_bkpf   TYPE gtys_bkpf
                             piv_buzei  TYPE bseg-buzei
                    CHANGING pct_acc_tx TYPE bapiactx09_tab
                             pct_cur_am TYPE bapiaccr09_tab.

  DATA: ls_tax    LIKE LINE OF pit_tax.
  DATA: ls_acc_tx LIKE LINE OF pct_acc_tx.
  DATA: ls_cur_am LIKE LINE OF pct_cur_am.
  DATA: lv_buzei  TYPE bseg-buzei.

  DATA: BEGIN OF ls_collect,
          mwskz TYPE mwskz,
          kschl TYPE kschl,
          ktosl TYPE ktosl,
          hkont TYPE hkont,
          wmwst TYPE wmwst,
          kawrt TYPE kawrt,
        END OF ls_collect.
  DATA: lt_collect LIKE HASHED TABLE OF ls_collect
                   WITH UNIQUE KEY mwskz ktosl kschl hkont.

* Steuern m√ºssen wir schon ermittelt haben
  IF NOT pit_tax IS INITIAL.

*   √úber den Collect werden Steuer und Steuerbasis summiert
*   und ggf. verdichtet
    LOOP AT pit_tax INTO ls_tax.
      MOVE-CORRESPONDING ls_tax TO ls_collect.
      COLLECT ls_collect INTO lt_collect.
    ENDLOOP.

*   Wir kopieren die letzte Zeilennummer
    lv_buzei = piv_buzei.

*   Und los
    LOOP AT lt_collect INTO ls_collect.
*     Eins auf die Buchungszeile da wir eine neue
*     Zeile erzuegen
      ADD 1 TO lv_buzei.
      CLEAR ls_acc_tx.
*     √úbertragung der Steuerdaten
      MOVE: lv_buzei         TO ls_acc_tx-itemno_acc,
            ls_collect-hkont TO ls_acc_tx-gl_account,
            ls_collect-kschl TO ls_acc_tx-cond_key,
            ls_collect-ktosl TO ls_acc_tx-acct_key,
            ls_collect-mwskz TO ls_acc_tx-tax_code.
*     Und anh√§ngen
      APPEND ls_acc_tx TO pct_acc_tx.

*     Da dies nur die Parameter f√ºr die Steuerzeile sind,
*     m√ºssen wir auch noch eine Wertezeile erzeugen
      CLEAR ls_cur_am.
*     Gleiche Zeile wie Steuerzeile (Bezug!!!)
      MOVE: lv_buzei         TO ls_cur_am-itemno_acc,
            pis_bkpf-waers   TO ls_cur_am-currency,
            pis_bkpf-waers   TO ls_cur_am-currency_iso,
*           Ermittelter, summierter Steuerwert f√ºr Steuerkennzeichen
            ls_collect-wmwst TO ls_cur_am-amt_doccur,
*           Ermittelter, summierter Basiswert f√ºr Steuerkennzeichen
            ls_collect-kawrt TO ls_cur_am-amt_base,
            '00'             TO ls_cur_am-curr_type,
*           Umrechnungskurs f√ºr Fremdw√§hrung
*           ACHTUNG!!!
*           Entweder hier KURSF ODER!!!! im Kopf WWERT mitgeben!!!
            pis_bkpf-kursf   TO ls_cur_am-exch_rate.
      APPEND ls_cur_am TO pct_cur_am.
    ENDLOOP.
  ENDIF.

ENDFORM.
</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Der Beitrag <a href="/blog/buchungsbelege-erstellen/">Buchungsbelege erstellen</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
