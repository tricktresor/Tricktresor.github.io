<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:series="https://publishpress.com/"
	>

<channel>
	<title>Reports Archive - Tricktresor</title>
	<atom:link href="/blog/topics/programmierung/reports/feed/" rel="self" type="application/rss+xml" />
	<link></link>
	<description>Tipps und Tricks zu SAP R/3</description>
	<lastBuildDate>Mon, 11 Mar 2024 17:26:54 +0000</lastBuildDate>
	<language>de-DE</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.4.3</generator>

<image>
	<url>/wp-content/uploads/2019/02/cropped-Tricktresor-favicon-2019-32x32.png</url>
	<title>Reports Archive - Tricktresor</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>IMG-Struktur anzeigen</title>
		<link>/blog/img-struktur-anzeigen/</link>
		
		<dc:creator><![CDATA[Enno Wulff]]></dc:creator>
		<pubDate>Mon, 11 Mar 2024 17:10:33 +0000</pubDate>
				<category><![CDATA[Reports]]></category>
		<category><![CDATA[Info/ Doku/ Demo]]></category>
		<category><![CDATA[img]]></category>
		<category><![CDATA[einführungsleitfaden]]></category>
		<category><![CDATA[unternehmens-img]]></category>
		<category><![CDATA[img-struktur]]></category>
		<category><![CDATA[Knoten]]></category>
		<guid isPermaLink="false">/?p=1045109</guid>

					<description><![CDATA[<p>Für den ein oder anderen Fall kann es sinnvoll sein, eine Unternehmensstruktur (IMG) direkt anzeigen oder sogar editieren zu können. Hintergrundinfo Die IMG-Struktur wird hauptsächlich in den Tabellen TTREE und TTREET verwaltet. Eine IMG-Struktur hat eine GUID und kann über den Kurztext in Tabelle TTREET ermittelt werden. IMG steht übrigens für Implementation Guide (Einführungsleitfaden). Die Knoten einer Unternehmensstruktur kannst du im SAP-Customizing über Transaktion SPRO einsehen und aufrufen. Einzelne Knoten werden mit Transaktion SIMGH angezeigt....</p>
<p>Der Beitrag <a href="/blog/img-struktur-anzeigen/">IMG-Struktur anzeigen</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></description>
										<content:encoded><![CDATA[
<p>Für den ein oder anderen Fall kann es sinnvoll sein, eine Unternehmensstruktur (IMG) direkt anzeigen oder sogar editieren zu können. </p>



<figure class="wp-block-image size-full"><img fetchpriority="high" decoding="async" width="739" height="263" src="/wp-content/uploads/2024/03/image-9.png" alt="" class="wp-image-1045110" srcset="/wp-content/uploads/2024/03/image-9.png 739w, /wp-content/uploads/2024/03/image-9-300x107.png 300w" sizes="(max-width: 739px) 100vw, 739px" /></figure>



<h2 class="wp-block-heading">Hintergrundinfo</h2>



<p>Die IMG-Struktur wird hauptsächlich in den Tabellen TTREE und TTREET verwaltet. Eine IMG-Struktur hat eine GUID und kann über den Kurztext in Tabelle TTREET ermittelt werden. IMG steht übrigens für <em>Implementation Guide</em> (Einführungsleitfaden).</p>



<p>Die Knoten einer Unternehmensstruktur kannst du im SAP-Customizing über Transaktion SPRO einsehen und aufrufen.</p>



<p>Einzelne Knoten werden mit Transaktion SIMGH angezeigt. Erweiterungen zur Unternehmensstruktur kannst du mit Transaktion S_IMG_EXTENSION verwalten.</p>



<h2 class="wp-block-heading">Code</h2>



<p>Das folgende Programm bietet die Möglichkeit, eine IMG-Struktur direkt anzuzeigen oder zu bearbeiten.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">
PARAMETERS: 
  p_struct TYPE ttree-id OBLIGATORY,
  p_edit   TYPE xfeld.

START-OF-SELECTION.
  IF NOT p_struct IS INITIAL.
    CALL FUNCTION 'STREE_EXTERNAL_EDIT'
      EXPORTING
        structure_id   = p_struct
        language       = sy-langu
        edit_structure = 'X' 
        activity       = COND char1( WHEN p_edit = 'X' THEN 'E' ELSE 'D' ).
  ENDIF.</pre>
<p>Der Beitrag <a href="/blog/img-struktur-anzeigen/">IMG-Struktur anzeigen</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Code-Inspector-Prüfungen auflisten</title>
		<link>/blog/code-inspector-pruefungen-auflisten/</link>
		
		<dc:creator><![CDATA[Enno Wulff]]></dc:creator>
		<pubDate>Fri, 01 Sep 2023 14:51:12 +0000</pubDate>
				<category><![CDATA[Reports]]></category>
		<category><![CDATA[Info/ Doku/ Demo]]></category>
		<category><![CDATA[Programmierung]]></category>
		<guid isPermaLink="false">/?p=1043422</guid>

					<description><![CDATA[<p>Heute stand ich vor der Herausforderung, dass ich alle Code-Inspector-Prüfungen herausfinden wollte, die in einer Prüfvariante aktiv sind. Natürlich kann man sich diese über die Pflege der Varianten im Code-Inspector über Transaktion SCI anzeigen lassen. Allerdings wird hier der gesamte Baum der verfügbaren Prüfungen aufgelistet und man muss sich die heraussuchen, die aktiviert sind. Eine nervige und Fehleranfällige Aufgabe, wenn man die aktiven Prüfungen irgendwie dokumentieren möchte. So sieht die Baumstruktur der Prüfungen aus: Um...</p>
<p>Der Beitrag <a href="/blog/code-inspector-pruefungen-auflisten/">Code-Inspector-Prüfungen auflisten</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></description>
										<content:encoded><![CDATA[
<p>Heute stand ich vor der Herausforderung, dass ich alle Code-Inspector-Prüfungen herausfinden wollte, die in einer Prüfvariante aktiv sind. Natürlich kann man sich diese über die Pflege der Varianten im Code-Inspector über Transaktion SCI anzeigen lassen. Allerdings wird hier der gesamte Baum der verfügbaren Prüfungen aufgelistet und man muss sich die heraussuchen, die aktiviert sind. Eine nervige und Fehleranfällige Aufgabe, wenn man die aktiven Prüfungen irgendwie dokumentieren möchte.</p>



<p>So sieht die Baumstruktur der Prüfungen aus:</p>



<figure class="wp-block-image size-full"><img decoding="async" width="778" height="201" src="/wp-content/uploads/2023/09/image.png" alt="" class="wp-image-1043423" srcset="/wp-content/uploads/2023/09/image.png 778w, /wp-content/uploads/2023/09/image-300x78.png 300w, /wp-content/uploads/2023/09/image-768x198.png 768w" sizes="(max-width: 778px) 100vw, 778px" /></figure>



<p>Um die technischen Texte anstelle der Beschreibungen anzuzeigen, gehe über das Menü <em>Prüfvariante • Anzeigen • Technische Namen</em>.</p>



<h2 class="wp-block-heading">Auflistung der aktiven Prüfvarianten</h2>



<p>Mit dem folgenden Code werden die aktiven Prüfungen zu einer Prüfvariante ermittelt und ausgegeben. </p>



<figure class="wp-block-image size-full"><img decoding="async" width="725" height="270" src="/wp-content/uploads/2023/09/image-2.png" alt="" class="wp-image-1043426" srcset="/wp-content/uploads/2023/09/image-2.png 725w, /wp-content/uploads/2023/09/image-2-300x112.png 300w" sizes="(max-width: 725px) 100vw, 725px" /></figure>



<p>Wenn du die Prüfungen einer <em>globalen Prüfvariante</em> ermitteln möchtest, dann muss OWNER leer bleiben. Für eine <em>lokale Prüfvariante </em>setze den entsprechenden User ein.</p>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="526" height="365" src="/wp-content/uploads/2023/09/image-1.png" alt="" class="wp-image-1043425" srcset="/wp-content/uploads/2023/09/image-1.png 526w, /wp-content/uploads/2023/09/image-1-300x208.png 300w, /wp-content/uploads/2023/09/image-1-200x140.png 200w" sizes="(max-width: 526px) 100vw, 526px" /></figure>



<p></p>



<h2 class="wp-block-heading">Code</h2>



<pre class="EnlighterJSRAW" data-enlighter-language="abap" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">PARAMETERS name  TYPE scichkv_hd-checkvname DEFAULT 'DEFAULT'.
PARAMETERS owner TYPE scichkv_hd-ciuser     DEFAULT space.

START-OF-SELECTION.

  SELECT SINGLE * FROM scichkv_hd
      WHERE checkvname = @name     ##WARN_OK
        AND ciuser     = @owner                         "#EC CI_NOORDER
       INTO @DATA(variant_header).

  DATA(main) =  cl_ci_checkvariant=>get_ref(
     p_user                   = owner
     p_name                   = name ).
  CHECK main IS BOUND.

  main->get_info(
    EXCEPTIONS
      could_not_read_variant = 1
      OTHERS                 = 2 ).

  IF sy-subrc = 0.
    cl_demo_output=>display_data(
      VALUE string_table(
        FOR variant IN main->variant (
          CONV #( variant-testname ) ) ) ).
  ENDIF.</pre>
<p>Der Beitrag <a href="/blog/code-inspector-pruefungen-auflisten/">Code-Inspector-Prüfungen auflisten</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Übersicht über gesperrte Objekte</title>
		<link>/blog/uebersicht-ueber-gesperrte-objekte/</link>
		
		<dc:creator><![CDATA[Enno Wulff]]></dc:creator>
		<pubDate>Fri, 07 Jan 2022 18:13:35 +0000</pubDate>
				<category><![CDATA[Reports]]></category>
		<category><![CDATA[Transportauftrag]]></category>
		<guid isPermaLink="false">/?p=1033240</guid>

					<description><![CDATA[<p>Bevor man damit beginnt, eine vorhandene Applikation zu erweitern oder umfangreich anzupassen, könnte man auf die Idee kommen, prüfen zu wollen, ob die beteiligten Objekte eventuell gerade gesperrt sind. In diesem Fall könnte man die Entwicklung nämlich nicht reibungslos durchführen. Die Änderung des gesperrten Objektes wird dann nämlich dem bereits vorhandenen Transportauftrag zugeordnet. Das wiederum bedeutet, dass die Transportaufträge gemeinsam transportiert werden müssen. Um prüfen zu können, welche Objekte gesperrt sind, habe ich einen kleinen...</p>
<p>Der Beitrag <a href="/blog/uebersicht-ueber-gesperrte-objekte/">Übersicht über gesperrte Objekte</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></description>
										<content:encoded><![CDATA[
<p>Bevor man damit beginnt, eine vorhandene Applikation zu erweitern oder umfangreich anzupassen, könnte man auf die Idee kommen, prüfen zu wollen, ob die beteiligten Objekte eventuell gerade gesperrt sind. In diesem Fall könnte man die Entwicklung nämlich nicht reibungslos durchführen. Die Änderung des gesperrten Objektes wird dann nämlich dem bereits vorhandenen Transportauftrag zugeordnet. Das wiederum bedeutet, dass die Transportaufträge gemeinsam transportiert werden müssen. </p>



<p>Um prüfen zu können, welche Objekte gesperrt sind, habe ich einen kleinen Report geschrieben. Er gibt eine Liste der selektierten Objekte aus und zeigt an, ob diese gesperrt sind oder nicht. Sind sie gesperrt, dann wird auch der Transportauftrag angezeigt, in dem das Objekt gesperrt ist.</p>



<p>Mit einem Klick auf den Transportauftrag wird dieser angezeigt.</p>



<h2 class="wp-block-heading" id="code">Code</h2>



<pre class="wp-block-preformatted">REPORT.

DATA gs_tadir TYPE tadir.
DATA gv_trkorr TYPE trkorr.

SELECT-OPTIONS so_objt FOR gs_tadir-object   DEFAULT 'PROG'.
SELECT-OPTIONS so_objn FOR gs_tadir-obj_name DEFAULT 'ZVTEST*' OPTION CP.
SELECT-OPTIONS so_devc FOR gs_tadir-devclass.

PARAMETERS     pa_onlyl AS CHECKBOX DEFAULT space.

AT LINE-SELECTION.

  CHECK gv_trkorr IS NOT INITIAL.
  CALL FUNCTION 'TR_DISPLAY_REQUEST'
    EXPORTING
      i_trkorr = gv_trkorr.

START-OF-SELECTION.

  PERFORM start.

FORM start.
  DATA ls_lockkey TYPE tlock_int.
  DATA lv_locked TYPE abap_bool.
  DATA lt_locks TYPE STANDARD TABLE OF tlock WITH DEFAULT KEY.

  SELECT * FROM tadir INTO TABLE @DATA(lt_tadir)
    WHERE object   IN @so_objt
      AND obj_name IN @so_objn
  AND devclass IN @so_devc.

  LOOP AT lt_tadir INTO gs_tadir.

    ls_lockkey-obj     = gs_tadir-object.
    ls_lockkey-low     = gs_tadir-obj_name.
    ls_lockkey-hi      = gs_tadir-obj_name &amp;&amp; '*'.

    CALL FUNCTION 'TRINT_CHECK_LOCKS'
      EXPORTING
        wi_lock_key = ls_lockkey
      IMPORTING
        we_lockflag = lv_locked
      TABLES
        wt_tlock    = lt_locks
      EXCEPTIONS
        empty_key   = 1.
    IF lv_locked = abap_false AND pa_onlyl = abap_true.
      CONTINUE.
    ENDIF.

    WRITE: /
      gs_tadir-object,
      gs_tadir-obj_name,
      gs_tadir-devclass.
    HIDE gs_tadir.

    IF lv_locked = abap_true.
      WRITE lv_locked COLOR COL_GROUP.
      gv_trkorr = lt_locks[ 1 ]-trkorr.
      HIDE gv_trkorr.
      SELECT * FROM e07t
        INTO TABLE @DATA(lt_e07t)
      WHERE trkorr = @gv_trkorr.
      WRITE: gv_trkorr HOTSPOT ON.
      IF sy-subrc = 0.
        DATA(lv_trtxt) = lt_e07t[ 1 ]-as4text.
        WRITE:  lv_trtxt.
      ENDIF.

    ENDIF.

  ENDLOOP.

  CLEAR gs_tadir.
  CLEAR gv_trkorr.

ENDFORM.</pre>
<p>Der Beitrag <a href="/blog/uebersicht-ueber-gesperrte-objekte/">Übersicht über gesperrte Objekte</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Aufmerksamkeit erlangen &#8211; SAPGUI Modus in den Vordergrund</title>
		<link>/blog/aufmerksamkeit-erlangen/</link>
		
		<dc:creator><![CDATA[Enno Wulff]]></dc:creator>
		<pubDate>Thu, 10 Jun 2021 11:01:27 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[Reports]]></category>
		<category><![CDATA[Programmierung]]></category>
		<category><![CDATA[GUI]]></category>
		<category><![CDATA[Modus]]></category>
		<category><![CDATA[SAPGUI]]></category>
		<guid isPermaLink="false">/?p=1029150</guid>

					<description><![CDATA[<p>Obwohl der SAPGUI bereits als &#8220;tot&#8221; eingestuft wird, finden sich immer wieder neue Erkenntnisse&#8230; In diesem Beitrag zeige ich dir, wie du einen SAPGUI-Modus in den Vordergrund bringen kannst, um die Aufmerksamkeit des Anwenders zurückzuerlangen. Solange der Anwender nur SAPGUI-Modi anzeigt, wird der gewünschte SAPGUI-Modus in den Vordergrund kommen und die anderen Fenster überlagern. Sollte noch ein anderes Programm (Browser, Outlook, Excel etc.), dann wird der Wunsch nach Aufmerksamkeit durch ein Blinken des SAPGUI-Icons in...</p>
<p>Der Beitrag <a href="/blog/aufmerksamkeit-erlangen/">Aufmerksamkeit erlangen &#8211; SAPGUI Modus in den Vordergrund</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></description>
										<content:encoded><![CDATA[
<p>Obwohl der SAPGUI bereits als &#8220;tot&#8221; eingestuft wird, finden sich immer wieder neue Erkenntnisse&#8230; In diesem Beitrag zeige ich dir, wie du einen SAPGUI-Modus in den Vordergrund bringen kannst, um die Aufmerksamkeit des Anwenders zurückzuerlangen. </p>



<p>Solange der Anwender nur SAPGUI-Modi anzeigt, wird der gewünschte SAPGUI-Modus in den Vordergrund kommen und die anderen Fenster überlagern. Sollte noch ein anderes Programm (Browser, Outlook, Excel etc.), dann wird der Wunsch nach Aufmerksamkeit durch ein Blinken des SAPGUI-Icons in der Taskleiste angezeigt.</p>



<p>Das folgende Programm kannst du in zwei verschiedenen Modi starten um den Effekt zu sehen. Die beiden Modi sollten möglichst übereinander (nicht nebeneinander) liegen, um den Effekt erkennen zu können.</p>



<h2 class="wp-block-heading">Coding</h2>



<pre class="wp-block-code"><code>REPORT zz_activate_gui_mode.

*--------------------------------------------------------------------*
* Programm in 2 verschiedenen Modi aufrufen und etwa 1 Sekunde versetzt starten!
*--------------------------------------------------------------------*

DO 10 TIMES.
  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
    EXPORTING
      text = |Modus: { sy-modno }  Index: { sy-index }|.

  CALL FUNCTION 'SAPGUI_SET_PROPERTY'
    DESTINATION 'SAPGUI'
    EXPORTING
      property = 'ACTIVATE'
      value    = 'X'
    EXCEPTIONS
      OTHERS   = 0.

  WAIT UP TO 3 SECONDS.
ENDDO.</code></pre>
<p>Der Beitrag <a href="/blog/aufmerksamkeit-erlangen/">Aufmerksamkeit erlangen &#8211; SAPGUI Modus in den Vordergrund</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Periodischer Job mit unabhängigen Steps</title>
		<link>/blog/periodischer-job-mit-unabhaengigen-steps/</link>
		
		<dc:creator><![CDATA[Enno Wulff]]></dc:creator>
		<pubDate>Mon, 08 Mar 2021 13:19:59 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[Reports]]></category>
		<category><![CDATA[job]]></category>
		<category><![CDATA[steps]]></category>
		<category><![CDATA[periodisch]]></category>
		<guid isPermaLink="false">/?p=1026410</guid>

					<description><![CDATA[<p>Jobeinplanungen sind im täglichen Betrieb eines SAP-Systems nicht wegzudenken und gehören zum "Daily Business". Trotzdem gibt es hin und wieder eine Anforderung, die trotz jahrelanger ausgeklügelter Techniken nicht ausreicht. In diesem Fall ein periodischer Job mit voneinander unabhängigen Verarbeitungsschritten.</p>
<p>Der Beitrag <a href="/blog/periodischer-job-mit-unabhaengigen-steps/">Periodischer Job mit unabhängigen Steps</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></description>
										<content:encoded><![CDATA[
<p>Jobverarbeitung is in vielen Bereichen und für viele Funktionalitäten wichtig. Jobeinplanungen sind eine gängige Technik, die jahrzehntelang erprobt ist. Kürzlich bin ich in einem Projekt auf eine Anforderung gestoßen, die nicht so ohne Weiteres mit den Standardmitteln der Jobeinplanung möglich war.</p>



<h2 class="wp-block-heading">Anforderung</h2>



<p>Es soll ein periodischer Job mit mehreren Steps eingeplant werden, deren Verarbeitungsschritte (Steps) unabhängig voneinander sind. Unabhängig heißt in diesem Fall, dass ein Verarbeitungsschritt, der durch einen Kurzdump abbricht, die Ausführung der anderen Schritte nicht beeinträchtigen soll. </p>



<h3 class="wp-block-heading">Möglichkeit 1</h3>



<p>Die erste auf der Hand liegende Möglichkeit ist, einen Job periodisch einzuplanen, der einzelne Verarbeitungsschritte enthält. Leider bricht der gesamte Job ab, wenn einer der Verarbeitungsschritte durch einen Shortdump abbricht. Diese Möglichkeit kommt also nicht in Betracht.</p>



<h3 class="wp-block-heading">Möglichkeit 2</h3>



<p>Die zweite Möglichkeit wäre, die einzelnen Verarbeitungsschritte als einzelne Jobs zu definieren und jeweils den einen Job als Vorgänger des jeweils nächsten Jobs zu definieren. Aber auch hier gibt es eine Einschränkung: Diese Jobs können nicht periodisch geplant werden. </p>



<h2 class="wp-block-heading">Lösung</h2>



<p>Die Lösung für mich war in diesem Fall natürlich ein ABAP Programm. Das folgende Programm kann man periodisch als Job einplanen und hier bis zu fünf Programme unabhängig voneinander, jeweils mit Vorgänger &#8211; Nachfolger-Beziehung, definieren. Wenn das Programm ausgeführt wird, startet es das erste Programm sofort als Job. Das zweite Programm wird gestartet, wenn der Job für das erste Programm beendet wurde und so weiter. Dabei ist es unerheblich, ob der Vorgängerjob regulär beendet wurde oder abgebrochen ist. </p>



<p>Das Programm ist fest auf fünf Verarbeitungsschritte ausgelegt. Es kann einfach auf weitere Steps erweitert werden. Sofern noch sehr viele Verarbeitungsschritte verwaltet werden sollten, sollte man die Verarbeitung dynamisch programmieren. Dafür müsste man jedoch auch die Eingabe für die Definition der Verarbeitungsschritte so anpassen, dass die einzelnen Programme in einer Liste (Grid) eingegeben werden können. </p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="549" height="579" src="/wp-content/uploads/2021/03/SNAG-01324.png" alt="" class="wp-image-1026411" srcset="/wp-content/uploads/2021/03/SNAG-01324.png 549w, /wp-content/uploads/2021/03/SNAG-01324-284x300.png 284w" sizes="(max-width: 549px) 100vw, 549px" /><figcaption>Report mit beispielhaften Reporteinplanungen</figcaption></figure>



<h2 class="wp-block-heading">Coding</h2>



<pre class="wp-block-preformatted">REPORT z_schedule_05_jobs_periodic.

PARAMETERS nam1 TYPE btcjob     OBLIGATORY.
PARAMETERS rep1 TYPE syrepid    OBLIGATORY.
PARAMETERS var1 TYPE raldb_vari OBLIGATORY.
SELECTION-SCREEN SKIP 1.

PARAMETERS nam2 TYPE btcjob.
PARAMETERS rep2 TYPE syrepid.
PARAMETERS var2 TYPE raldb_vari.
SELECTION-SCREEN SKIP 1.

PARAMETERS nam3 TYPE btcjob.
PARAMETERS rep3 TYPE syrepid.
PARAMETERS var3 TYPE raldb_vari.
SELECTION-SCREEN SKIP 1.

PARAMETERS nam4 TYPE btcjob.
PARAMETERS rep4 TYPE syrepid.
PARAMETERS var4 TYPE raldb_vari.
SELECTION-SCREEN SKIP 1.

PARAMETERS nam5 TYPE btcjob.
PARAMETERS rep5 TYPE syrepid.
PARAMETERS var5 TYPE raldb_vari.


CLASS lcx_job DEFINITION INHERITING FROM cx_static_check.
ENDCLASS.

CLASS lcl_define_job DEFINITION.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        iv_name    TYPE btcjob
        iv_report  TYPE syrepid
        iv_variant TYPE raldb_vari
      RAISING
        lcx_job.

    METHODS start
      IMPORTING
        iv_pred_jobcount TYPE btcjobcnt OPTIONAL
        iv_pred_jobname  TYPE btcjob OPTIONAL
      RAISING
        lcx_job.

    DATA mv_jobcount     TYPE btcjobcnt.
    DATA mv_jobname      TYPE btcjob.
    DATA mv_released     TYPE abap_bool.

ENDCLASS.

CLASS lcl_define_job IMPLEMENTATION.
  METHOD constructor.

    mv_jobname = iv_name.

    CALL FUNCTION 'JOB_OPEN'
      EXPORTING
        jobname          = iv_name
      IMPORTING
        jobcount         = mv_jobcount
      EXCEPTIONS
        cant_create_job  = 1
        invalid_job_data = 2
        jobname_missing  = 3
        OTHERS           = 4.
    IF sy-subrc = 0.
      CALL FUNCTION 'JOB_SUBMIT'
        EXPORTING
          authcknam               = sy-uname
          jobcount                = mv_jobcount
          jobname                 = iv_name
          report                  = iv_report
          variant                 = iv_variant
        EXCEPTIONS
          bad_priparams           = 1
          bad_xpgflags            = 2
          invalid_jobdata         = 3
          jobname_missing         = 4
          job_notex               = 5
          job_submit_failed       = 6
          lock_failed             = 7
          program_missing         = 8
          prog_abap_and_extpg_set = 9
          OTHERS                  = 10.
      IF sy-subrc &lt;> 0.
        RAISE EXCEPTION TYPE lcx_job.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD start.

    CALL FUNCTION 'JOB_CLOSE'
      EXPORTING
        jobcount             = mv_jobcount
        jobname              = mv_jobname
        pred_jobcount        = iv_pred_jobcount
        pred_jobname         = iv_pred_jobname
        strtimmed            = SWITCH #( iv_pred_jobcount WHEN space THEN 'X' ELSE space )
      IMPORTING
        job_was_released     = mv_released
      EXCEPTIONS
        cant_start_immediate = 1
        invalid_startdate    = 2
        jobname_missing      = 3
        job_close_failed     = 4
        job_nosteps          = 5
        job_notex            = 6
        lock_failed          = 7
        invalid_target       = 8
        OTHERS               = 9.
    IF sy-subrc &lt;> 0.
      RAISE EXCEPTION TYPE lcx_job.
    ENDIF.
  ENDMETHOD.
ENDCLASS.


START-OF-SELECTION.

  TRY.

      DATA(job1) = NEW lcl_define_job(
        iv_name    = nam1
        iv_report  = rep1
        iv_variant = var1 ).
      job1->start( ).

      IF rep2 IS NOT INITIAL.
        DATA(job2) = NEW lcl_define_job(
          iv_name    = nam2
          iv_report  = rep2
          iv_variant = var2 ).
        job2->start(
          iv_pred_jobname  = job1->mv_jobname
          iv_pred_jobcount = job1->mv_jobcount ).
      ENDIF.

      IF rep3 IS NOT INITIAL.
        DATA(job3) = NEW lcl_define_job(
          iv_name    = nam3
          iv_report  = rep3
          iv_variant = var3 ).
        job3->start(
          iv_pred_jobname  = job2->mv_jobname
          iv_pred_jobcount = job2->mv_jobcount ).
      ENDIF.

      IF rep4 IS NOT INITIAL.
        DATA(job4) = NEW lcl_define_job(
          iv_name    = nam4
          iv_report  = rep4
          iv_variant = var4 ).
        job4->start(
          iv_pred_jobname  = job3->mv_jobname
          iv_pred_jobcount = job3->mv_jobcount ).
      ENDIF.

      IF rep5 IS NOT INITIAL.
        DATA(job5) = NEW lcl_define_job(
          iv_name    = nam5
          iv_report  = rep5
          iv_variant = var5 ).
        job5->start(
          iv_pred_jobname  = job4->mv_jobname
          iv_pred_jobcount = job4->mv_jobcount ).
      ENDIF.
    CATCH lcx_job.
      MESSAGE 'Error job creation!' TYPE 'I'.
  ENDTRY.</pre>
<p>Der Beitrag <a href="/blog/periodischer-job-mit-unabhaengigen-steps/">Periodischer Job mit unabhängigen Steps</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Dateiausgabe in Zwischenablage umleiten</title>
		<link>/blog/dateiausgabe-in-zwischenablage-umleiten/</link>
		
		<dc:creator><![CDATA[Enno Wulff]]></dc:creator>
		<pubDate>Thu, 20 Feb 2020 07:27:28 +0000</pubDate>
				<category><![CDATA[Reports]]></category>
		<category><![CDATA[Info/ Doku/ Demo]]></category>
		<category><![CDATA[Blog]]></category>
		<category><![CDATA[exe]]></category>
		<category><![CDATA[zwischenablage]]></category>
		<category><![CDATA[cl_gui_frontend_services]]></category>
		<guid isPermaLink="false">/?p=1023236</guid>

					<description><![CDATA[<p>Im Forum kam die Frage auf, wie man am einfachsten das Ergebnis eines Betriebssystemkommandos beziehungsweise eines EXE-Programms in ABAP einlesen kann. Stefan hat einen genialen Trick aufgezeigt (Danke dafür!!): Mit Hilfe des Systemkommandos CLIP wird die Ausgabe einfach in die Windows-Zwischenablage umgeleitet. Das Einlesen der Zwischenablage in eine interne Tabelle ist mit Hilfe von CL_GUI_FRONTEND_SERVICES=>CLIPBOARD_IMPORT dann ebenfalls einfach möglich. Demoprogramm</p>
<p>Der Beitrag <a href="/blog/dateiausgabe-in-zwischenablage-umleiten/">Dateiausgabe in Zwischenablage umleiten</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></description>
										<content:encoded><![CDATA[
<p>Im Forum kam die Frage auf, wie man am einfachsten das Ergebnis eines Betriebssystemkommandos beziehungsweise eines EXE-Programms in ABAP einlesen kann. </p>



<p>Stefan hat einen genialen Trick aufgezeigt (Danke dafür!!): Mit Hilfe des Systemkommandos <a href="https://ss64.com/nt/clip.html">CLIP</a> wird die Ausgabe einfach in die Windows-Zwischenablage umgeleitet.</p>



<p>Das Einlesen der Zwischenablage in eine interne Tabelle ist mit Hilfe von CL_GUI_FRONTEND_SERVICES=>CLIPBOARD_IMPORT dann ebenfalls einfach möglich.</p>



<h2 class="wp-block-heading">Demoprogramm</h2>



<pre class="wp-block-code"><code>DATA clipboard   TYPE STANDARD TABLE OF char255 with EMPTY KEY.
cl_gui_frontend_services=>execute(
  EXPORTING
    application = 'cmd.exe'
    parameter   = '/C "dir c:\temp\*.* | clip"'
    minimized   = 'X' " disable cmd flash
    synchronous = 'X' " wait for cmd to finish
  EXCEPTIONS
    OTHERS      = 10 ).
cl_gui_frontend_services=>clipboard_import(
  IMPORTING
    data     = clipboard
    length   = DATA(length)
  EXCEPTIONS
    OTHERS   = 4 ).

cl_demo_output=>display_data( clipboard ).</code></pre>



<p></p>
<p>Der Beitrag <a href="/blog/dateiausgabe-in-zwischenablage-umleiten/">Dateiausgabe in Zwischenablage umleiten</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Persönliches Favoriten-Menü</title>
		<link>/blog/persoenliches-favoriten-menue/</link>
		
		<dc:creator><![CDATA[Enno Wulff]]></dc:creator>
		<pubDate>Wed, 02 May 2018 18:02:50 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[Reports]]></category>
		<category><![CDATA[report]]></category>
		<category><![CDATA[Menü]]></category>
		<category><![CDATA[selection-screen]]></category>
		<category><![CDATA[macros]]></category>
		<category><![CDATA[Varianten]]></category>
		<guid isPermaLink="false">https://tricktresor.com/?p=1018447</guid>

					<description><![CDATA[<p>Die Favoriten im SAP-Menü erleichtern die Arbeit vieler Anwender bereits deutlich. Die am häufigsten genutzten Transaktionen können im Enjoy-Menü einfach verwaltet werden. Allerdings beschränkt sich das Ganze auf Transaktionen und Web-Adressen (plus ein paar andere &#8220;sonstige Objekte&#8221;). Wilfried Schäfer hat einen Report geschrieben, mit dem du dir dein persönliches Menü zusammenbauen kannst. Hierbei können nicht nur Transaktionen aufgenommen werden, sondern auch Reports inklusive Varianten. Aber auch Tabellen (SE16n), Pflegeviews (SM30) und Viewcluster (SM34) können aufgenommen...</p>
<p>Der Beitrag <a href="/blog/persoenliches-favoriten-menue/">Persönliches Favoriten-Menü</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Die Favoriten im SAP-Menü erleichtern die Arbeit vieler Anwender bereits deutlich. Die am häufigsten genutzten Transaktionen können im Enjoy-Menü einfach verwaltet werden. Allerdings beschränkt sich das Ganze auf <em>Transaktionen</em> und <em>Web-Adressen</em> (plus ein paar andere &#8220;sonstige Objekte&#8221;).</p>
<p>Wilfried Schäfer hat einen Report geschrieben, mit dem du dir dein persönliches Menü zusammenbauen kannst. Hierbei können nicht nur Transaktionen aufgenommen werden, sondern auch Reports inklusive Varianten.</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2018/05/ws01.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-1018448" src="https://tricktresor.com/wp-content/uploads/2018/05/ws01.png" alt="" width="690" height="139" srcset="/wp-content/uploads/2018/05/ws01.png 690w, /wp-content/uploads/2018/05/ws01-300x60.png 300w" sizes="(max-width: 690px) 100vw, 690px" /></a></p>
<p>Aber auch Tabellen (SE16n), Pflegeviews (SM30) und Viewcluster (SM34) können aufgenommen werden.</p>
<h2>Trick</h2>
<p>Der geniale Trick bei diesem Report ist, dass die einzelnen Einträge als <em>stinknormale</em> Variante abgespeichert werden. Auch die Texte und Eingabebereitschaft der einzelnen Felder wird in der Variante gespeichert.</p>
<h2>Verwendung</h2>
<p>Der Report kann gut zur Gruppierung von Funktionen verwendet werden, die entweder ebenfalls häufig benötigt werden, oder eben auch nur recht selten (Monats,- Jahresabschluss).</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2018/05/ws02.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-1018450" src="https://tricktresor.com/wp-content/uploads/2018/05/ws02.png" alt="" width="687" height="303" srcset="/wp-content/uploads/2018/05/ws02.png 687w, /wp-content/uploads/2018/05/ws02-300x132.png 300w" sizes="(max-width: 687px) 100vw, 687px" /></a></p>
<h2>Code und Doku</h2>
<p>Die Dokumentation und der Quelltext kannst du dir hier herunterladen: <a href="https://tricktresor.com/wp-content/uploads/2018/05/Report-ZZ_ME.pdf">Report ZZ_ME.pdf</a></p>
<h2>Code</h2>
<pre class="lang:abap decode:true ">REPORT zz_menue.

*=======================================================================
*
* Funktion:     Start Transaktion, Submit Reports mit und ohne Varianten
* Beschreibung: Das Selektionsbild dieses Reports wird benutzt, um mit
*               gesepeicherten Varianten eine Art von Menue-Liste zu
*               erhalten. Aus dem Selektionsbild können die Varianten
*               geöffnet oder gestartet werden.
*
*               User ohne SA38-Berechtigung können keine Reports ein-
*               tragen. Das Starten von Transaktionen mit Varianten
*               wird auch unterstützt.
*
*               Alles was nicht Transaktion oder Report ist, wird als
*               Kommentar interpretiert.
*
*                                             Wilfried Schäfer
*
*                                             wilfried.schaefer@arcor.de
*=======================================================================
* Möglicher Inhalt der Spalte "Variant / Table" abhängig vom Inhalt der
* Spalte "Report/Transaktion"
*
*  Report/Transaktion  Variant / Table
* ______________________________________
*
*  SE11  oder
*  SE16  oder
*  SE16N oder
*  SE17  oder
*  SE54  oder
*  SM30  oder
*  SM31                Tabelle
*  SM34                View Clusters
*  SE37                Funktionsbaustein
*  SA38  oder
*  SE38                Report
*  SE51                Report
*  SE71                SAPscript Formular
*
*  Reportname          Variante
*  Transaktionscode    Variante
*  GR55.Reportgruppe   Variante
*
*=======================================================================
*
* Aktionstypen: B Berichtsgruppe
*               C Kommentar
*               H Report mit Variante zur Ausführung im Hintergrund
*               h Transaktion mit Variante zur Ausführung im Hintergrund
*               R Report
*               T Transaktion
*               V Report mit Variante / Berichtsgruppe mit Variante
*               v Transaktion mit Variante
*
*=======================================================================

INCLUDE &lt;list&gt;.                   " List enthält alle icons

TABLES: trdir, trdirt,    " Reports
        tfdir,            " Funktionsbausteine
        tstc,  tstct,     " SAP-Transaktions-Codes
        tstcp,            " Parameter zu Transaktionen
        dd02l, dd02t,     " SAP-Tabellen /-Texte
        varid, varit,     " Varianten
        sscrfields,       " Felder auf Selektionsbildern
        t803vp,           " Report Writer: Generierte Programmversionen
        vcldir, vcldirt,  " Viewcluster.
        stxh,             " STXD SAPscript Text-Datei Header
        tftit.            " Kurztext Funktionsbaustein

*============= Selektionskriterien ====================================

SELECTION-SCREEN FUNCTION KEY 1.
SELECTION-SCREEN FUNCTION KEY 2.
SELECTION-SCREEN FUNCTION KEY 3.
SELECTION-SCREEN FUNCTION KEY 4.

SELECTION-SCREEN BEGIN OF BLOCK comment_lines.
*                             WITH FRAME. " TITLE text_U11.

* 1. Comment line
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 01.  SELECTION-SCREEN COMMENT (07) text_u11.
SELECTION-SCREEN POSITION 10.   PARAMETERS  pm_c001(60) LOWER CASE
                                                        MODIF ID com.
SELECTION-SCREEN END OF LINE.

* 2. Comment line
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 10.   PARAMETERS  pm_c002(50) LOWER CASE
                                                        MODIF ID com.
SELECTION-SCREEN POSITION 79.
SELECTION-SCREEN END OF LINE.

* 3. Comment line
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 10.   PARAMETERS  pm_c003(50) LOWER CASE
                                                        MODIF ID com.
SELECTION-SCREEN END OF LINE.

* 4. Comment line
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 10.   PARAMETERS  pm_c004(50) LOWER CASE
                                                        MODIF ID com.
SELECTION-SCREEN POSITION 68.
SELECTION-SCREEN PUSHBUTTON (45) pb1_txt USER-COMMAND uc_refresh_comm
                                        MODIF ID pb
                                        VISIBLE LENGTH 45.
SELECTION-SCREEN END OF LINE.

* 5. Comment line
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 10.   PARAMETERS  pm_c005(50) LOWER CASE
                                                        MODIF ID com.
SELECTION-SCREEN POSITION 61.
PARAMETERS: p_hide01(7) MODIF ID nod.
SELECTION-SCREEN POSITION 68.
SELECTION-SCREEN PUSHBUTTON (45) pb2_txt USER-COMMAND
                                          uc_refresh_line_comm
                                          MODIF ID pb
                                          VISIBLE LENGTH 45.


SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN SKIP.

* Eine Selop, die nicht angezeigt wird, ist notwendig, damit SY-OPTI
* abgefragt werden kann.
SELECT-OPTIONS pm_vari FOR varid-variant MODIF ID nod.

SELECTION-SCREEN END OF BLOCK comment_lines.

*Wenn die Zeile mit "Report / Transaktions" beginnt
*SELECTION-SCREEN BEGIN OF LINE.
* SELECTION-SCREEN POSITION  3. SELECTION-SCREEN COMMENT (28) TEXT_U01.
* SELECTION-SCREEN POSITION 34. SELECTION-SCREEN COMMENT (16) TEXT_U02.
* SELECTION-SCREEN POSITION 60. SELECTION-SCREEN COMMENT (04) TEXT_U03.
* SELECTION-SCREEN POSITION 66. SELECTION-SCREEN COMMENT (04) TEXT_U04.
* SELECTION-SCREEN POSITION 72. SELECTION-SCREEN COMMENT (09) TEXT_U12.
* SELECTION-SCREEN POSITION 81.
*SELECTION-SCREEN END OF LINE.

*Wenn die Zeile mit "Description" beginnt
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION  1. SELECTION-SCREEN COMMENT (15) text_u12.
SELECTION-SCREEN POSITION 46. SELECTION-SCREEN COMMENT (04) text_u03.
SELECTION-SCREEN POSITION 52. SELECTION-SCREEN COMMENT (04) text_u04.
SELECTION-SCREEN POSITION 57. SELECTION-SCREEN COMMENT (20) text_u01.
SELECTION-SCREEN POSITION 83. SELECTION-SCREEN COMMENT (16) text_u02.
SELECTION-SCREEN END OF LINE.

*============================================================

SELECTION-SCREEN BEGIN OF BLOCK action_lines.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS  p_c_togl(10)               MODIF ID nd2.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS  p_r_togl(100)              MODIF ID nd2.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS  p_v_togl(100)              MODIF ID nd2.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
PARAMETERS  p_i_togl(100)              MODIF ID nd2.
SELECTION-SCREEN END OF LINE.

*============================================================

TYPES: text40 TYPE c LENGTH 40.

DATA: wk_p_v(30),
      wk_c40k    LIKE makt-maktx,
      wk_c30k    LIKE docclsst-text30.

*=======================================================================
DEFINE line6.
*     p_r_&amp;1         Report
*     p_v_&amp;1         Variante
*     p_i_&amp;1         Information / comment.

*Wenn die Zeile mit "Report / Transaktions" beginnt
*SELECTION-SCREEN BEGIN OF LINE.
*SELECTION-SCREEN POSITION 1.  PARAMETERS: P_R_&amp;1(40) LOWER CASE
*                                                     VISIBLE LENGTH 30
*                                                     MODIF ID P_R.
*SELECTION-SCREEN POSITION 32. PARAMETERS: P_V_&amp;1(30) LOWER CASE
*                                                     VISIBLE LENGTH 25
*                                                     MODIF ID CHK.
*SELECTION-SCREEN PUSHBUTTON 58(4) T_B1&amp;1 USER-COMMAND OPEN_&amp;1
*                                                     MODIF ID OPN
*                                                     VISIBLE LENGTH 4.
*SELECTION-SCREEN PUSHBUTTON 63(4) T_B2&amp;1 USER-COMMAND SUBM_&amp;1
*                                                     MODIF ID SUB
*                                                     VISIBLE LENGTH 4.
*
*SELECTION-SCREEN POSITION 70. PARAMETERS: P_I_&amp;1(70) LOWER CASE
*                                          VISIBLE LENGTH 70
*                                          MODIF ID P_I.
*
*SELECTION-SCREEN END OF LINE.

*Wenn die Zeile mit "Description" beginnt
  SELECTION-SCREEN BEGIN OF LINE.
  SELECTION-SCREEN POSITION 1. PARAMETERS: p_i_&amp;1(100) LOWER CASE
                                            VISIBLE LENGTH 45
                                            MODIF ID p_i.
  SELECTION-SCREEN PUSHBUTTON 47(4) t_b1&amp;1 USER-COMMAND open_&amp;1
                                                       MODIF ID opn
                                                       VISIBLE LENGTH 4.
  SELECTION-SCREEN PUSHBUTTON 52(60) t_b2&amp;1 USER-COMMAND subm_&amp;1
                                                       MODIF ID sub
                                                       VISIBLE LENGTH 4.

  SELECTION-SCREEN POSITION 57.  PARAMETERS: p_r_&amp;1(40) LOWER CASE
                                                       VISIBLE LENGTH 25
                                                       MODIF ID p_r.
  SELECTION-SCREEN POSITION 83. PARAMETERS: p_v_&amp;1(30) LOWER CASE
                                                       VISIBLE LENGTH 30
                                                       MODIF ID chk.

  SELECTION-SCREEN END OF LINE.

END-OF-DEFINITION.                   "Line6
*=======================================================================

line6 s001. line6 s002. line6 s003. line6 s004. line6 s005.
line6 s006. line6 s007. line6 s008. line6 s009. line6 s010.

line6 s011. line6 s012. line6 s013. line6 s014. line6 s015.
line6 s016. line6 s017. line6 s018. line6 s019. line6 s020.

line6 s021. line6 s022. line6 s023. line6 s024. line6 s025.
line6 s026. line6 s027. line6 s028. line6 s029. line6 s030.

line6 s031. line6 s032. line6 s033. line6 s034. line6 s035.
line6 s036. line6 s037. line6 s038. line6 s039. line6 s040.

line6 s041. line6 s042. line6 s043. line6 s044. line6 s045.
line6 s046. line6 s047. line6 s048. line6 s049. line6 s050.

line6 s051. line6 s052. line6 s053. line6 s054. line6 s055.
line6 s056. line6 s057. line6 s058. line6 s059. line6 s060.

line6 s061. line6 s062. line6 s063. line6 s064. line6 s065.
line6 s066. line6 s067. line6 s068. line6 s069. line6 s070.

line6 s071. line6 s072. line6 s073. line6 s074. line6 s075.
line6 s076. line6 s077. line6 s078. line6 s079. line6 s080.

line6 s081. line6 s082. line6 s083. line6 s084. line6 s085.
line6 s086. line6 s087. line6 s088. line6 s089. line6 s090.

line6 s091. line6 s092. line6 s093. line6 s094. line6 s095.
line6 s096. line6 s097. line6 s098. line6 s099.

*=======================================================================
DEFINE sine6.

  DATA: s_r_&amp;1    TYPE programm,            "Report
        s_v_&amp;1    TYPE varid-variant,       "Variante
        s_i_&amp;1(55).                         "Description

END-OF-DEFINITION.

sine6 s001. sine6 s002. sine6 s003. sine6 s004. sine6 s005.
sine6 s006. sine6 s007. sine6 s008. sine6 s009. sine6 s010.

sine6 s011. sine6 s012. sine6 s013. sine6 s014. sine6 s015.
sine6 s016. sine6 s017. sine6 s018. sine6 s019. sine6 s020.

sine6 s021. sine6 s022. sine6 s023. sine6 s024. sine6 s025.
sine6 s026. sine6 s027. sine6 s028. sine6 s029. sine6 s030.

sine6 s031. sine6 s032. sine6 s033. sine6 s034. sine6 s035.
sine6 s036. sine6 s037. sine6 s038. sine6 s039. sine6 s040.

sine6 s041. sine6 s042. sine6 s043. sine6 s044. sine6 s045.
sine6 s046. sine6 s047. sine6 s048. sine6 s049. sine6 s050.


sine6 s051. sine6 s052. sine6 s053. sine6 s054. sine6 s055.
sine6 s056. sine6 s057. sine6 s058. sine6 s059. sine6 s060.

sine6 s061. sine6 s062. sine6 s063. sine6 s064. sine6 s065.
sine6 s066. sine6 s067. sine6 s068. sine6 s069. sine6 s070.

sine6 s071. sine6 s072. sine6 s073. sine6 s074. sine6 s075.
sine6 s076. sine6 s077. sine6 s078. sine6 s079. sine6 s080.

sine6 s081. sine6 s082. sine6 s083. sine6 s084. sine6 s085.
sine6 s086. sine6 s087. sine6 s088. sine6 s089. sine6 s090.

sine6 s091. sine6 s092. sine6 s093. sine6 s094. sine6 s095.
sine6 s096. sine6 s097. sine6 s098. sine6 s099.

SELECTION-SCREEN END OF BLOCK action_lines.
*=====================================================================

DATA: wk_filename          LIKE rlgrap-filename,
      wk_flength           TYPE f,
      wk_zae1(3)           TYPE p,
      wk_div_0             TYPE p,
      wk_div_1             TYPE p,
      wk_first_step(3)     TYPE n   VALUE 1,
      wk_last_step(3)      TYPE n,
      wk_message(100),
      wk_cursor_field(20),
      wk_field_content(40),
      wk_dyntxt            LIKE smp_dyntxt,
      wk_memcheck,
      wk_actiontype        TYPE text120,
      wk_zz_me             TYPE text120,
      wk_variant           LIKE varid-variant,
      wk_refresh_line(3)   TYPE n,
      wk_nothing_to_do,
      wk_gr55_repname(40),
      wk_tstcp_repname(40),
      wk_sa38_allowed,
      wk_ucomm             LIKE sy-ucomm,

      wk_ende.

DATA: us_repid LIKE trdir-name,
      us_vari  LIKE varid-variant,
      us_cond,
      us_date  LIKE sy-datum,
      us_x(2)  TYPE n.

DATA: l_nod,
      x_opn       TYPE i,
      x_sub       TYPE i,
      fn_repid(8),              " like trdir-name,
      fn_vari(8),               " like varid-variant,
      x(3)        TYPE n,

      ende.

DATA: BEGIN OF tab  OCCURS 0,
        step(2)          TYPE n,
        next(3)          TYPE n,
        rep              LIKE trdir-name,
        vari(30),
        cond(1),
        date             LIKE sy-datum,
        info(55),
        ignore_line,
        error_reason(50),
      END OF tab.

DATA: BEGIN  OF memory_prerep,
        prerep LIKE sy-repid.
DATA: END OF memory_prerep.

DATA: BEGIN  OF memory_info,
        step_hierarchy(40).
DATA: END OF memory_info.

DATA: BEGIN OF s_mem,
        memory(20),
        service(1),
        2nd_run(1),
        exit_1(1),
        exit_2(1),
        zvariant_default LIKE varid-variant,
        no_uname_select,
        prev_rep         LIKE sy-repid.
DATA: END OF s_mem.

DATA: BEGIN OF s_mem2,
        zvariant_default LIKE varid-variant.
DATA: END OF s_mem2.

DATA: cdd_seltab    TYPE TABLE OF rsparams,
      cdd_seltab_wa LIKE LINE OF cdd_seltab.

RANGES r_vari   FOR varid-variant.

FIELD-SYMBOLS: &lt;fs_1&gt;, &lt;fs_repid&gt;, &lt;fs_vari&gt;, &lt;fs_text&gt;, &lt;fs_date&gt;.

*================ Aufbereiten Selektionsbild vor 1. Anzeige ===========

INITIALIZATION.

  IF sy-slset = space.
    PERFORM pruef_default_variant.
  ENDIF.

*Feststellen, ob der User SA38-Berechtigung hat.

  AUTHORITY-CHECK OBJECT 'S_TCODE'
                  ID     'TCD'  FIELD  'SA38'.
  IF sy-subrc = 0.
    text_u01 = 'Report / Transaction'.
    wk_sa38_allowed = 'X'.
  ELSE.
    text_u01 = 'Transaction'.
  ENDIF.

  text_u02 = 'Variant / Table'.
  text_u03 = 'Open'.
  text_u04 = 'Run'.
  text_u11 = 'Comment'.
  text_u12 = 'Description'.

  DATA: lpb1t(8) VALUE 'T_B1S',
        lpb2t(8) VALUE 'T_B2S'.

  FIELD-SYMBOLS: &lt;fs_pb1&gt;, &lt;fs_pb2&gt;.

  DO 99 TIMES.
    ADD 1 TO x.
    lpb1t+5 = x.
    lpb2t+5 = x.
    ASSIGN (lpb1t) TO &lt;fs_pb1&gt;. &lt;fs_pb1&gt; =  '@09@'.
    ASSIGN (lpb2t) TO &lt;fs_pb2&gt;. &lt;fs_pb2&gt; =  '@08@'.
  ENDDO.

  pb1_txt  = '@42@Refresh all descriptions'.
  pb2_txt  = '@4K@Refresh description of cursor line'.

  CLEAR wk_dyntxt.
  MOVE 'Field toggle display/modify'
    TO  wk_dyntxt-text.                                       "Text
  MOVE 'Toggle on cursor field between display/modify mode!'
    TO  wk_dyntxt-quickinfo.                                  "Quickinfo
  MOVE  icon_toggle_display_change
    TO  wk_dyntxt-icon_id.
  MOVE 'Field toggle display/modify'
    TO  wk_dyntxt-icon_text.                                  "Ikonentext
  MOVE  wk_dyntxt TO sscrfields-functxt_01.

  CLEAR wk_dyntxt.
  MOVE 'Insert Line'               TO wk_dyntxt-text.      "Text
  MOVE 'Insert a line on cursor position'
    TO  wk_dyntxt-quickinfo. "Quickinfo
  MOVE icon_insert_row             TO wk_dyntxt-icon_id.
  MOVE 'Insert Line '
    TO                                              wk_dyntxt-icon_text.
  "Ikonentext
  MOVE wk_dyntxt TO sscrfields-functxt_02.

  CLEAR wk_dyntxt.
  MOVE 'Delete Line'               TO wk_dyntxt-text.      "Text
  MOVE 'Delete the line of cursor position'
    TO  wk_dyntxt-quickinfo. "Quickinfo
  MOVE  icon_delete_row             TO wk_dyntxt-icon_id.
  MOVE 'Delete Line '
    TO   wk_dyntxt-icon_text. "Ikonentext
  MOVE wk_dyntxt TO sscrfields-functxt_03.

  CLEAR wk_dyntxt.
  MOVE 'Clear Screen'              TO wk_dyntxt-text.      "Text
  MOVE 'clear Screen          '    TO wk_dyntxt-quickinfo. "Quickinfo
  MOVE icon_erase                  TO wk_dyntxt-icon_id.
  MOVE 'Clear screen      '        TO wk_dyntxt-icon_text. "Ikonentext
  MOVE wk_dyntxt TO sscrfields-functxt_04.

* LOOP AT SCREEN.
*   IF SCREEN-GROUP1 = 'VIW'.
*      SCREEN-INPUT       = 'OFF'.
*      MODIFY SCREEN.
*   ENDIF.
* ENDLOOP.

*======================================================================
FORM pruef_default_variant.
*======================================================================

  IMPORT wk_memcheck        FROM MEMORY ID 'WK_MEMCHECK'.
  FREE MEMORY                           ID 'WK_MEMCHECK'.
  CHECK wk_memcheck = space.

  DATA wk_back.
  IMPORT wk_back            FROM MEMORY ID 'WK_BACK'.
  IF sy-slset &lt;&gt; space.
    FREE MEMORY                        ID 'WK_BACK'.
  ENDIF.
  CHECK wk_back = space.

* Gibt es für den User nur eine Variante, dann wird diese gestartet.

  DATA: l_count   TYPE i,
        l_variant LIKE varid-variant.

  RANGES r_variant FOR varid-variant.

  SELECT * FROM varid WHERE report = sy-repid
                       AND  ename  = sy-uname.

    IF varid-variant(2) = 'Z:'.
      CHECK varid-variant+2 = sy-uname.
    ENDIF.

    ADD 1 TO l_count.
    l_variant = varid-variant.

    IF l_count &gt; 1.
      EXIT.
    ENDIF.
  ENDSELECT.

*Es kann auch eine Z:USERNAME-Variante geben, die ein anderer
*User angelegt hat.

  IF l_count = 0.
    CONCATENATE 'Z:' sy-uname INTO l_variant.
    SELECT SINGLE * FROM varid WHERE report  = sy-repid
                          AND  variant = l_variant.
    IF sy-subrc = 0.
      ADD 1 TO l_count.
    ENDIF.
  ENDIF.

  IF l_count  = 1.
    wk_memcheck = 'X'.
    EXPORT wk_memcheck            TO MEMORY ID 'WK_MEMCHECK'.

    SUBMIT (sy-repid) VIA SELECTION-SCREEN
                      USING SELECTION-SET l_variant.
  ENDIF.

  PERFORM check_user_vari_exist.

ENDFORM.
*=====================================================================
FORM check_user_vari_exist.
*=====================================================================
  RANGES r_vari   FOR varid-variant.

* Gibt es für diesen Report keine Z:USERNAME-Variante keine
* USERNAME:-Varianten und nicht nur eine Variante, dann wird der
* Sel-Screen mit den vorhandenen Varianten (max. 99) gefüllt.

**DATA: BEGIN OF T_ZVISE OCCURS 0.
**      INCLUDE STRUCTURE ZVISE.
**DATA: END OF T_ZVISE.
**
**DATA: BEGIN OF SELTAB_1 OCCURS 0,
**      TABNAME LIKE ZVISE-TABNAME.
**DATA: END OF SELTAB_1.
**
**DATA: BEGIN OF S_MEM,
**      MEMORY(20),
**      SERVICE(1),
**      2ND_RUN(1),
**      EXIT_1(1),
**      EXIT_2(1),
**      ZVARIANT_DEFAULT  LIKE VARID-VARIANT,
**      NO_UNAME_SELECT,
**      PREV_REP          LIKE SY-REPID.
**DATA: END OF S_MEM.

  DATA: wk_uname             LIKE sy-uname,
        wk_clear_entry,
        wk_vari_default_list.

  wk_uname = sy-uname.

  DATA: l_vari               LIKE varid-variant,
        l_strlen             TYPE i,
        l_count              TYPE i,
        l_num3(3)            TYPE n,
        l_screen_field_r(20),
        l_screen_field_v(20).

  FIELD-SYMBOLS &lt;fs_screen_r&gt;.
  FIELD-SYMBOLS &lt;fs_screen_v&gt;.

  CONCATENATE sy-uname ':' INTO l_vari.
  l_strlen = strlen( l_vari ).

  CLEAR cdd_seltab.
  cdd_seltab_wa-selname = 'P_REPORT'.
  cdd_seltab_wa-kind    = 'S'.
  cdd_seltab_wa-sign    = 'I'.
  cdd_seltab_wa-option  = 'EQ'.
  cdd_seltab_wa-low     =  sy-repid.

  SELECT * FROM varid WHERE report  =  sy-repid
                       AND  ename   =  sy-uname.

    IF varid-variant(2)      = 'Z:'.
      CHECK varid-variant+2 = sy-uname.
    ENDIF.

    ADD 1 TO l_count.

* Hier nun den Sel-Screen mit den vorhandenen Varianten füllen

    IF l_count &lt; 99.
      ADD 1 TO l_num3.
      CONCATENATE 'P_R_S' l_num3 INTO l_screen_field_r.
      CONCATENATE 'P_V_S' l_num3 INTO l_screen_field_v.
      ASSIGN (l_screen_field_r) TO &lt;fs_screen_r&gt;.
      ASSIGN (l_screen_field_v) TO &lt;fs_screen_v&gt;.

      &lt;fs_screen_r&gt; = varid-report.
      &lt;fs_screen_v&gt; = varid-variant.
    ENDIF.
  ENDSELECT.

*Jetzt noch die Z:USERNAME-Variante, die von einem anderen User
*angelegt wurde.

  IF l_count &lt; 99.
    CONCATENATE 'Z:' sy-uname INTO l_vari.

    SELECT SINGLE * FROM varid WHERE report  =  sy-repid
                                AND  ename   &lt;&gt; sy-uname
                                AND  variant =  l_vari.
    IF sy-subrc = 0.
      ADD 1 TO l_count.
      ADD 1 TO l_num3.
      CONCATENATE 'P_R_S' l_num3 INTO l_screen_field_r.
      CONCATENATE 'P_V_S' l_num3 INTO l_screen_field_v.
      ASSIGN (l_screen_field_r) TO &lt;fs_screen_r&gt;.
      ASSIGN (l_screen_field_v) TO &lt;fs_screen_v&gt;.

      &lt;fs_screen_r&gt; = varid-report.
      &lt;fs_screen_v&gt; = varid-variant.
    ENDIF.
  ENDIF.

ENDFORM.

*================ Aufbereiten Selektionsbild vor jeder Anzeige ========
AT SELECTION-SCREEN OUTPUT.
*======================================================================
  DATA: l_nod,
        x_opn       TYPE i,
        x_sub       TYPE i,
        fn_repid(8),              " like trdir-name,
        fn_vari(8),               " like varid-variant,
        fn_info(8),
        x(3)        TYPE n,
        l_pos(3)    TYPE n,
        l_b1(8)     VALUE 'T_B1S000',
        l_b2(8)     VALUE 'T_B2S000',
        n3(3)       TYPE n,

        ende.

  FIELD-SYMBOLS: &lt;fs_1&gt;,  &lt;fs_repid&gt;, &lt;fs_vari&gt;, &lt;fs_text&gt;, &lt;fs_date&gt;,
                 &lt;fs_b1&gt;, &lt;fs_b2&gt;,    &lt;fs_info&gt;.

*Feststellen, ob der User SA38-Berechtigung hat.

  AUTHORITY-CHECK OBJECT 'S_TCODE'
                  ID     'TCD'  FIELD  'SA38'.
  IF sy-subrc = 0.
    text_u01 = 'Report / Transaction'.
    wk_sa38_allowed = 'X'.
  ELSE.
    text_u01 = 'Transaction'.
  ENDIF.

  LOOP AT SCREEN.

    IF p_hide01 &lt;&gt; 'DISPLAY'.
      IF screen-name   = 'C2_DIS' OR
         screen-name   = 'C4_MOD'.
        screen-input  = '0'.
        screen-output = '0'.
        screen-invisible   = '1'.
        MODIFY SCREEN.
      ENDIF.
    ENDIF.

    IF screen-name BETWEEN 'PM_C001' AND 'PM_C199'.
      l_pos = screen-name+5.
      IF p_c_togl+l_pos(1)  &lt;&gt; ' '.
        screen-input  = '0'.
        MODIFY SCREEN.
      ENDIF.

      fn_info =  screen-name.  ASSIGN (fn_info)  TO &lt;fs_info&gt;.
      IF &lt;fs_info&gt;+0(1) = '@'  AND
         &lt;fs_info&gt;+3(1) = '@'.
        TRANSLATE &lt;fs_info&gt;+1(2) TO UPPER CASE.
      ENDIF.

    ENDIF.

    IF screen-name BETWEEN 'P_R_S001' AND 'P_R_S199'.
      l_pos = screen-name+6.
      IF p_r_togl+l_pos(1)  &lt;&gt; ' '.
        screen-input  = '0'.
        MODIFY SCREEN.
      ENDIF.
    ENDIF.

    IF screen-name BETWEEN 'P_V_S001' AND 'P_V_S199'.
      l_pos = screen-name+6.
      IF p_v_togl+l_pos(1)  &lt;&gt; ' '.
        screen-input  = '0'.
        MODIFY SCREEN.
      ENDIF.
    ENDIF.

    IF screen-name BETWEEN 'P_I_S001' AND 'P_I_S199'.
      l_pos = screen-name+6.
      IF p_i_togl+l_pos(1)  &lt;&gt; ' '.
        screen-input  = '0'.
        MODIFY SCREEN.
      ENDIF.
      fn_info =  screen-name.  ASSIGN (fn_info)  TO &lt;fs_info&gt;.
      IF &lt;fs_info&gt;+0(1) = '@'  AND
         &lt;fs_info&gt;+3(1) = '@'.
        TRANSLATE &lt;fs_info&gt;+1(2) TO UPPER CASE.
      ENDIF.
    ENDIF.

    IF screen-group1 = 'CHK'.
      fn_vari       =  screen-name.  ASSIGN (fn_vari)  TO &lt;fs_vari&gt;.
      fn_repid      =  fn_vari.
      fn_repid+2(1) = 'R'.           ASSIGN (fn_repid) TO &lt;fs_repid&gt;.

      IF &lt;fs_vari&gt;+0(1) = '@'  AND
         &lt;fs_vari&gt;+3(1) = '@'.
        TRANSLATE &lt;fs_vari&gt;+1(2) TO UPPER CASE.
      ENDIF.

      x = fn_vari.

      IF &lt;fs_repid&gt; = space.
        wk_actiontype+x(1) = 'C'.
      ELSE.
        PERFORM pruef_step USING  x &lt;fs_repid&gt; &lt;fs_vari&gt;
                                     fn_repid   fn_vari.
      ENDIF.
    ENDIF.

* IF SCREEN-GROUP1      = 'VIW'.
*    SCREEN-INPUT       = 'OFF'.
*    MODIFY SCREEN.
* ENDIF.

    IF screen-group1      = 'NOD'.
      screen-invisible   = '1'.
      screen-input       = '0'.
      screen-output      = '0'.
      MODIFY SCREEN.
    ENDIF.

    IF screen-group1      = 'ND2'.
      screen-invisible   = '1'.
      screen-input       = '0'.
      screen-output      = '0'.
      MODIFY SCREEN.
    ENDIF.

    IF screen-group1      =  'PB3'.
      screen-invisible   = '1'.
      screen-input       = '0'.
      screen-output      = '0'.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.

  x_opn = 0.
  x_sub = 0.

  LOOP AT SCREEN.

    IF screen-group1 = 'CHK'.
      fn_vari       =  screen-name.  ASSIGN (fn_vari)  TO &lt;fs_vari&gt;.
      fn_repid      =  fn_vari.
      fn_repid+2(1) = 'R'.           ASSIGN (fn_repid) TO &lt;fs_repid&gt;.
    ENDIF.

    IF screen-group1 = 'OPN'.
      ADD 1 TO x_opn.

      IF wk_actiontype+x_opn(1) = 'C' OR
         wk_actiontype+x_opn(1) = ' '.
        screen-invisible   = '1'.
        screen-input       = '0'.
        screen-output      = '0'.
        MODIFY SCREEN.
      ELSE.
        n3 = x_opn.
        l_b1+5 = n3.
        ASSIGN (l_b1) TO &lt;fs_b1&gt;.
        &lt;fs_b1&gt; = '@09@'.
        MODIFY SCREEN.
      ENDIF.
    ENDIF.

    IF screen-group1 = 'SUB'.
      ADD 1 TO x_sub.

      n3 = x_sub.
      l_b2+5 = n3.
      ASSIGN (l_b2) TO &lt;fs_b2&gt;.

      IF wk_actiontype+x_sub(1) = 'H' OR
         wk_actiontype+x_sub(1) = 'h'.
        &lt;fs_b2&gt; = '@M4@'.
        &lt;fs_b2&gt;+5
                = 'Variant has flag "Only for Background Processing"'.
        MODIFY SCREEN.
      ELSE.
        &lt;fs_b2&gt; = '@08@'.
        MODIFY SCREEN.
      ENDIF.

      IF wk_actiontype+x_sub(1) = 'v' OR
         wk_actiontype+x_sub(1) = 'V' OR
         wk_actiontype+x_sub(1) = 'H' OR
         wk_actiontype+x_sub(1) = 'h'.
      ELSE.
        screen-invisible   = '1'.
        screen-input       = '0'.
        screen-output      = '0'.
        MODIFY SCREEN.
      ENDIF.

      IF wk_zz_me+x_sub(1)  = 'X'.
        screen-invisible   = '1'.
        screen-input       = '0'.
        screen-output      = '0'.
        MODIFY SCREEN.
      ENDIF.
    ENDIF.
  ENDLOOP.

  IF wk_ucomm = 'UC_ZZ_DIS_MODE'  OR
     p_hide01 = 'DISPLAY'.
    p_hide01 = 'DISPLAY'.
    MODIFY SCREEN.
    PERFORM switch_to_display_mode.
  ENDIF.

  IF wk_ucomm = 'UC_ZZ_MOD_MODE'             OR
     p_hide01 = 'MODIFY'  OR
     p_hide01 =  space.
    p_hide01 = 'MODIFY'.
    MODIFY SCREEN.
    PERFORM switch_to_modify_mode.
  ENDIF.

  IF p_hide01 &lt;&gt; 'DISPLAY'.
    LOOP AT SCREEN.
      CHECK screen-name(4) = 'PM_C'
       OR   screen-name(4) = 'P_R_'
       OR   screen-name(4) = 'P_V_'
       OR   screen-name(4) = 'P_I_'.
      l_pos = screen-name+5.

      CASE screen-name(4).
        WHEN 'PM_C'.
          IF    p_c_togl+l_pos(1) = space.
            screen-input = '1'.
          ELSE.
            screen-input = '0'.
            screen-display_3d   = '1'.
          ENDIF.
        WHEN 'P_R_'.
          IF    p_r_togl+l_pos(1) = space.
            screen-input = '1'.
          ELSE.
            screen-input = '0'.
            screen-display_3d   = '1'.
          ENDIF.
        WHEN 'P_V_'.
          IF    p_v_togl+l_pos(1) = space.
            screen-input = '1'.
          ELSE.
            screen-input = '0'.
            screen-display_3d   = '1'.
          ENDIF.
        WHEN 'P_I_'.
          IF    p_i_togl+l_pos(1) = space.
            screen-input = '1'.
          ELSE.
            screen-input = '0'.
            screen-display_3d   = '1'.
          ENDIF.
      ENDCASE.
      MODIFY SCREEN.
    ENDLOOP.
  ENDIF.

  PERFORM get_comments.

*======================================================================
FORM switch_to_display_mode.
*======================================================================

  LOOP AT SCREEN.
    IF screen-group1 = 'PBM'.
      screen-input       = '1'.
      MODIFY SCREEN.
    ENDIF.
    CHECK screen-group1 = 'P_R'
       OR  screen-group1 = 'P_I'
       OR  screen-group1 = 'CHK'
       OR  screen-group1 = 'COM'
       OR  screen-group1 = 'PBD'
       OR  screen-group1 = 'PB'.
    .
    screen-input        = '0'.
    screen-intensified  = '0'.
    screen-display_3d   = '1'.
    MODIFY SCREEN.
  ENDLOOP.

ENDFORM.
*======================================================================
FORM switch_to_modify_mode.
*======================================================================

  LOOP AT SCREEN.
    IF screen-group1 = 'PBM'.
      screen-input       = '0'.
      MODIFY SCREEN.
    ENDIF.
    CHECK screen-group1 = 'P_R'
      OR  screen-group1 = 'P_I'
      OR  screen-group1 = 'CHK'
      OR  screen-group1 = 'COM'
      OR  screen-group1 = 'PBD'
      OR  screen-group1 = 'PB'.
    screen-input        = '1'.
    screen-intensified  = '0'.
    screen-display_3d   = '0'.
    MODIFY SCREEN.
  ENDLOOP.

ENDFORM.
*======================================================================
FORM get_comments.
*======================================================================
  DATA: fn_text(8),
        l_repid      LIKE sy-repid,
        ls_repid     TYPE program,
        ls_vari(30),
        l_actiontype.

  DATA: BEGIN OF t_varid,
          report  LIKE varid-report,
          variant LIKE varid-variant,
          mlangu  LIKE varid-mlangu,
          langu   LIKE varit-langu,
          vtext   LIKE varit-vtext.
  DATA  END OF t_varid.

  DATA: BEGIN OF t_varid_trans,
          tcode   LIKE tstc-tcode,
          report  LIKE varid-report,
          variant LIKE varid-variant,
          mlangu  LIKE varid-mlangu,
          langu   LIKE varit-langu,
          vtext   LIKE varit-vtext.
  DATA  END OF t_varid_trans.

  DATA: lt_varid       LIKE TABLE OF t_varid,
        lt_varid_trans LIKE TABLE OF t_varid_trans,
        ll_varid       LIKE t_varid,
        ll_varid_trans LIKE t_varid_trans.

  CLEAR x.

  DO 99 TIMES.
    ADD 1 TO x.

    CONCATENATE 'P_V_S' x INTO fn_vari.   ASSIGN (fn_vari)  TO &lt;fs_vari&gt;.
    fn_repid      =  fn_vari.
    fn_repid+2(1) = 'R'.                  ASSIGN (fn_repid) TO &lt;fs_repid&gt;.

    CHECK &lt;fs_repid&gt; &lt;&gt; space.

    fn_text       =  fn_vari.
    fn_text+2(1)  = 'I'.                  ASSIGN (fn_text)  TO &lt;fs_text&gt;.

    IF sy-ucomm = 'UC_REFRESH_COMM'.
      CASE wk_actiontype+x(1).
        WHEN 'V'
         OR  'v'
         OR  'R'
         OR  'T'
         OR  'G'
         OR  'H'
         OR  'h'.    CLEAR &lt;fs_text&gt;.
      ENDCASE.
    ENDIF.
    IF sy-ucomm = 'UC_REFRESH_LINE_COMM'.
      CHECK wk_refresh_line = x.
      CASE wk_actiontype+x(1).
        WHEN 'V'
         OR  'v'
         OR  'R'
         OR  'T'
         OR  'G'
         OR  'H'
         OR  'h'.    CLEAR &lt;fs_text&gt;.
        WHEN OTHERS.
          wk_nothing_to_do = 'X'.
          EXIT.
      ENDCASE.
    ENDIF.

    CHECK &lt;fs_text&gt;  =  space.

    ls_repid = &lt;fs_repid&gt;.
    IF ls_repid(5) = 'GR55 '.
      ls_repid(5) = 'GR55.'.
      CONDENSE  ls_repid+5 NO-GAPS.
    ELSE.
      CONDENSE  ls_repid NO-GAPS.
    ENDIF.
    TRANSLATE ls_repid TO UPPER CASE.
    IF ls_repid(1)   = '@'  AND
       ls_repid+3(1) = '@'.
      ls_repid      =  ls_repid+4.
    ENDIF.

    ls_vari  = &lt;fs_vari&gt;.
    TRANSLATE ls_vari TO UPPER CASE.

    CASE wk_actiontype+x(1).
      WHEN 'G'.
        REFRESH lt_varid.
        CLEAR   t_varid.
        l_repid =  ls_repid.
        CLEAR wk_tstcp_repname.
        PERFORM get_tstcp_reportname USING 1  ls_repid   ls_vari
                                              ls_repid   ls_vari.
        l_repid = wk_tstcp_repname.

        DO 2 TIMES.
          SELECT a~report a~variant a~mlangu b~langu b~vtext
                 APPENDING TABLE lt_varid
                 FROM varid AS a
                  INNER JOIN varit AS b ON  a~report = b~report
                                        AND a~variant = b~variant
                  WHERE a~report = l_repid
                   AND  a~variant = ls_vari.

          IF sy-dbcnt &gt; 1.
            SORT lt_varid BY mlangu DESCENDING langu.
            LOOP AT lt_varid INTO t_varid.
              IF sy-langu = t_varid-langu.
                CLEAR t_varid-langu.
                MODIFY lt_varid FROM t_varid.
              ENDIF.
            ENDLOOP.

            SORT lt_varid BY langu mlangu.
          ENDIF.

          LOOP AT lt_varid INTO t_varid.
            EXIT.
          ENDLOOP.

          IF t_varid-vtext &lt;&gt; space.
            WRITE t_varid-vtext TO &lt;fs_text&gt;.
            EXIT.
          ENDIF.

          IF ls_vari+0(1) = '@' AND
             ls_vari+3(1) = '@'.
            ls_vari = ls_vari+4.
          ELSE.
            EXIT.
          ENDIF.
        ENDDO.

      WHEN 'V'
      OR   'H'. REFRESH lt_varid.
        CLEAR   t_varid.
        l_repid =  ls_repid.
        IF l_repid(5) = 'GR55=' OR
           l_repid(5) = 'GR55-' OR
           l_repid(5) = 'GR55_' OR
           l_repid(5) = 'GR55.' OR
           l_repid(5) = 'GR55,' OR
           l_repid(5) = 'GR55&gt;' OR
           l_repid(5) = 'GR55/'.
          CLEAR wk_gr55_repname.
          l_actiontype = wk_actiontype+x(1).
          PERFORM get_gr55_reportname USING 1  ls_repid   ls_vari
                                               ls_repid   ls_vari.
          l_repid = wk_gr55_repname.
          wk_actiontype+x(1) = l_actiontype.
        ENDIF.

        DO 2 TIMES.
          SELECT a~report a~variant a~mlangu b~langu b~vtext
                 APPENDING TABLE lt_varid
                 FROM varid AS a
                  INNER JOIN varit AS b ON  a~report = b~report
                                        AND a~variant = b~variant
                 WHERE a~report = l_repid
                  AND  a~variant = ls_vari.

          IF sy-dbcnt &gt; 1.
            SORT lt_varid BY mlangu DESCENDING langu.
            LOOP AT lt_varid INTO t_varid.
              IF sy-langu = t_varid-langu.
                CLEAR t_varid-langu.
                MODIFY lt_varid FROM t_varid.
              ENDIF.
            ENDLOOP.

            SORT lt_varid BY langu mlangu.
          ENDIF.

          LOOP AT lt_varid INTO t_varid.
            EXIT.
          ENDLOOP.

          IF t_varid-vtext &lt;&gt; space.
            WRITE t_varid-vtext TO &lt;fs_text&gt;.
            EXIT.
          ENDIF.

          IF ls_vari+0(1) = '@' AND
             ls_vari+3(1) = '@'.
            ls_vari = ls_vari+4.
          ELSE.
            EXIT.
          ENDIF.
        ENDDO.

      WHEN 'v'
      OR   'h'. REFRESH lt_varid_trans.
        l_repid =  ls_repid.
        IF       ls_repid(3)  = '/T/'.
          l_repid  = ls_repid+3.
        ELSE.
          l_repid  = ls_repid.
        ENDIF.

        DO 2 TIMES.
          SELECT t~tcode a~report a~variant a~mlangu b~langu b~vtext
                 APPENDING TABLE lt_varid_trans
                 FROM tstc AS t
                  INNER JOIN varid AS a ON  t~pgmna = a~report
                  INNER JOIN varit AS b ON  a~report = b~report
                                        AND a~variant = b~variant
                  WHERE t~tcode   = l_repid
                   AND  a~variant = ls_vari.

          IF sy-dbcnt &gt; 1.
            SORT lt_varid_trans BY mlangu DESCENDING langu.
            LOOP AT lt_varid_trans INTO t_varid_trans.
              IF sy-langu = t_varid_trans-langu.
                CLEAR t_varid_trans-langu.
                MODIFY lt_varid_trans FROM t_varid_trans.
              ENDIF.
            ENDLOOP.

            SORT lt_varid_trans BY langu mlangu.
          ENDIF.

          LOOP AT lt_varid_trans INTO t_varid_trans.
            EXIT.
          ENDLOOP.

          IF t_varid_trans-vtext &lt;&gt; space.
            WRITE t_varid_trans-vtext TO &lt;fs_text&gt;.
            EXIT.
          ENDIF.

          IF ls_vari+0(1) = '@' AND
             ls_vari+3(1) = '@'.
            ls_vari = ls_vari+4.
          ELSE.
            EXIT.
          ENDIF.
        ENDDO.

      WHEN 'R'.
        IF trdirt-name &lt;&gt; &lt;fs_repid&gt;.
          CLEAR trdirt.
        ENDIF.
        IF trdirt-text = space.
          SELECT SINGLE * FROM trdirt WHERE name  =  ls_repid
                                       AND  sprsl = sy-langu.
          IF sy-subrc &lt;&gt; 0.
            SELECT SINGLE * FROM trdirt WHERE name  =  ls_repid
                                         AND  sprsl = 'E'.
          ENDIF.
          IF sy-subrc &lt;&gt; 0.
            SELECT SINGLE * FROM trdirt WHERE name  =  ls_repid
                                         AND  sprsl = 'D'.
          ENDIF.
        ENDIF.
        &lt;fs_text&gt; = trdirt-text.

      WHEN 'B'.                                   "Berichtsgruppe aus GR55
        IF ls_vari+0(1) = '@'  AND
           ls_vari+3(1) = '@'.
          ls_vari = ls_vari+4.
        ENDIF.
        PERFORM get_gr55_reportname USING 1  ls_repid   ls_vari
                                             ls_repid   ls_vari.

        IF trdirt-name &lt;&gt; wk_gr55_repname.
          CLEAR trdirt.
        ENDIF.
        IF trdirt-text = space.
          SELECT SINGLE * FROM trdirt WHERE name = wk_gr55_repname
                                      AND  sprsl = sy-langu.
          IF sy-subrc &lt;&gt; 0.
            SELECT SINGLE * FROM trdirt WHERE name =
            wk_gr55_repname
                                        AND  sprsl = 'E'.
          ENDIF.
          IF sy-subrc &lt;&gt; 0.
            SELECT SINGLE * FROM trdirt WHERE name =
            wk_gr55_repname
                                        AND  sprsl = 'D'.
          ENDIF.
        ENDIF.
        &lt;fs_text&gt; = trdirt-text.

      WHEN 'T'.
        IF tstct-tcode &lt;&gt; &lt;fs_repid&gt;
         OR sy-ucomm = 'UC_REFRESH_LINE_COMM'
         OR sy-ucomm = 'UC_REFRESH_'.
          CLEAR: tstct, dd02t.
        ENDIF.
        CLEAR &lt;fs_text&gt;.

        IF &lt;fs_vari&gt;  &lt;&gt; space.

          IF ls_vari+0(1) = '@'  AND
             ls_vari+3(1) = '@'.
            ls_vari = ls_vari+4.
          ENDIF.
          CONDENSE ls_vari NO-GAPS.

          CASE  ls_repid.
            WHEN 'SE11'
             OR  'SE16'
             OR  'SE16N'
             OR  'SE17'
             OR  'SE54'
             OR  'SM30'
             OR  'SM31'.
              SELECT SINGLE * FROM dd02l WHERE tabname =  ls_vari.
              IF sy-subrc = 0.
                SELECT SINGLE * FROM dd02t
                       WHERE tabname    =  ls_vari
                        AND  ddlanguage = sy-langu.
                IF sy-subrc &lt;&gt; 0.
                  SELECT SINGLE * FROM dd02t
                      WHERE tabname    =  ls_vari
                          AND  ddlanguage = 'E'.
                ENDIF.
                IF sy-subrc &lt;&gt; 0.
                  SELECT SINGLE * FROM dd02t
                      WHERE tabname    =  ls_vari
                          AND  ddlanguage = 'D'.
                ENDIF.                     .
                IF dd02t-ddtext &lt;&gt; space.
                  &lt;fs_text&gt;   = dd02t-ddtext.
                  tstct-ttext = dd02t-ddtext.
                ENDIF.
              ENDIF.

            WHEN 'SM34'.
              SELECT SINGLE * FROM vcldirt
                              WHERE vclname    =  ls_vari
                               AND  spras   = sy-langu.
              IF sy-subrc = 0.
                &lt;fs_text&gt;   = vcldirt-text.
                tstct-ttext = vcldirt-text.
              ENDIF.

            WHEN 'SE71'.
              SELECT SINGLE * FROM stxh WHERE tdobject = 'FORM'
                                         AND  tdname    =  ls_vari
                                         AND  tdid     = 'TXT'
                                         AND  tdspras  = sy-langu.
              IF sy-subrc = 0.
                &lt;fs_text&gt;   = stxh-tdtitle.
                tstct-ttext = stxh-tdtitle.
              ENDIF.
            WHEN 'SE37'.
              SELECT SINGLE * FROM tftit
                              WHERE spras    = sy-langu
                               AND  funcname =  ls_vari.
              IF sy-subrc &lt;&gt; 0.
                SELECT SINGLE * FROM tftit
                                WHERE spras    = 'E'
                              AND  funcname =  ls_vari.
              ENDIF.
              IF sy-subrc &lt;&gt; 0.
                SELECT SINGLE * FROM tftit
                                WHERE spras    = 'D'
                              AND  funcname =  ls_vari.
              ENDIF.
              &lt;fs_text&gt; = tftit-stext.

            WHEN 'SE38'
             OR  'SA38'
             OR  'SE51'
             OR  'SE80'.
              SELECT SINGLE * FROM trdirt WHERE name  =  ls_vari
                                           AND  sprsl = sy-langu.
              IF sy-subrc &lt;&gt; 0.
                SELECT SINGLE * FROM trdirt
                                WHERE name  =  ls_vari
                                 AND  sprsl = 'E'.
              ENDIF.
              IF sy-subrc &lt;&gt; 0.
                SELECT SINGLE * FROM trdirt
                                WHERE name  =  ls_vari
                                 AND  sprsl = 'D'.
              ENDIF.
              &lt;fs_text&gt; = trdirt-text.

          ENDCASE.
        ENDIF.

        CHECK &lt;fs_text&gt;   = space.

        IF       ls_repid(3)  = '/T/'.
          l_repid  = ls_repid+3.
        ELSE.
          l_repid  = ls_repid.
        ENDIF.

        IF tstct-ttext = space.
          SELECT SINGLE * FROM tstct WHERE tcode = l_repid
                                      AND  sprsl = sy-langu.

          IF sy-subrc &lt;&gt; 0.
            SELECT SINGLE * FROM tstct WHERE tcode =  l_repid
                                        AND  sprsl = 'E'.
          ENDIF.
          IF sy-subrc &lt;&gt; 0.
            SELECT SINGLE * FROM tstct WHERE tcode =  l_repid
                                        AND  sprsl = 'D'.
          ENDIF.
          SELECT SINGLE * FROM tstc WHERE tcode = tstct-tcode.
          IF sy-subrc = 0  AND
             tstc-pgmna(4) = 'MENU'.
            CLEAR tstct.
          ENDIF.
        ENDIF.

        &lt;fs_text&gt; = tstct-ttext.
    ENDCASE.

    IF sy-ucomm = 'UC_REFRESH_LINE_COMM' AND
       wk_refresh_line = x.
      EXIT.
    ENDIF.
  ENDDO.

ENDFORM.
*======================================================================
AT SELECTION-SCREEN.
*======================================================================

  IF sy-ucomm = 'SPOS'.
    LOOP AT SCREEN.
      IF screen-group1 = 'ND2'.
        screen-invisible   = '0'.
        screen-input       = '1'.
        screen-output      = '1'.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
  ENDIF.

  CLEAR wk_nothing_to_do.

  IF sy-ucomm = 'UC_ZZ_DIS_MODE' OR
     sy-ucomm = 'UC_ZZ_MOD_MODE' OR
     sy-ucomm = 'OPTI'.
    wk_ucomm = sy-ucomm.
  ENDIF.

  IF sy-ucomm = 'UC_REFRESH_COMM'.
    PERFORM get_comments.
    MESSAGE 'If result is OK, do not forget to save the variant!'
            TYPE 'I'.
  ENDIF.

  IF sy-ucomm = 'UC_REFRESH_LINE_COMM'.
    GET CURSOR FIELD wk_cursor_field VALUE wk_field_content.
    IF wk_cursor_field+4 BETWEEN 'S001' AND 'S099'.
      wk_refresh_line = wk_cursor_field+5.
      PERFORM get_comments.
      IF wk_nothing_to_do = space.
        MESSAGE 'If result is OK, do not forget to save the variant!'
                TYPE 'I'.
      ELSE.
        MESSAGE 'Nothing to do fort that line!'
                TYPE 'I'.
      ENDIF.
    ELSE.
      MESSAGE 'Position your cursor on a valid line and try again!'
              TYPE 'I'.
    ENDIF.
  ENDIF.

*LOOP AT SCREEN.
*  IF SCREEN-GROUP1  = 'VIW'.
*     SCREEN-INPUT   = 'OFF'.
*     MODIFY SCREEN.
*  ENDIF.
*ENDLOOP.

  FIELD-SYMBOLS: &lt;fs_repid&gt;,  &lt;fs_vari&gt;,  &lt;fs_cond&gt;,  &lt;fs_date&gt;,
                 &lt;fs_fromu&gt;,  &lt;fs_comm&gt;,

                 &lt;fs_prepid&gt;, &lt;fs_pvari&gt;, &lt;fs_pcond&gt;, &lt;fs_pdate&gt;,
                 &lt;fs_pfromu&gt;, &lt;fs_pcomm&gt;.

  DATA: fn_repid(8),              " like trdir-name,
        fn_vari(8),               " like varid-variant,
        fn_cond(8),
        fn_date     LIKE sy-datum,
        fn_fromu(8),
        fn_comm(8),
        x(3)        TYPE n,
        ende.

  IF sy-ucomm = 'OPTI'.
    sy-ucomm = 'FC01'.    "Zur Vermeidung unsinniger Meldung

    wk_message = 'Open Variant'.
    PERFORM open_variant.
  ENDIF.

  IF sy-ucomm(6) = 'OPEN_S'.
    PERFORM open_variant.
  ENDIF.

  IF sy-ucomm(6) = 'SUBM_S'.
    PERFORM submit_variant.
  ENDIF.

  IF sscrfields-ucomm = 'FC01'.
    IF sscrfields-functxt_01 &lt;&gt; space.
      PERFORM toggle_field.
      EXIT.
    ENDIF.
  ENDIF.

  IF sscrfields-ucomm = 'FC02'.
    IF sscrfields-functxt_02 &lt;&gt; space.
      PERFORM insert_line.
      EXIT.
    ENDIF.
  ENDIF.

  IF sscrfields-ucomm = 'FC03'.
    IF sscrfields-functxt_03 &lt;&gt; space.
      PERFORM delete_line.
      EXIT.
    ENDIF.
  ENDIF.

  IF sscrfields-ucomm = 'FC04'.
    IF sscrfields-functxt_04 &lt;&gt; space.
      PERFORM clear_screen.
      EXIT.
    ENDIF.
  ENDIF.

  x = 0.

  DO 99 TIMES.                        "For 99 possible Steps
    ADD 1 TO x.

    CLEAR tab.
    fn_repid = 'P_R_S'. fn_repid+5 = x. ASSIGN (fn_repid) TO &lt;fs_repid&gt;.
    fn_vari  = 'P_V_S'. fn_vari+5  = x. ASSIGN (fn_vari)  TO &lt;fs_vari&gt;.
    fn_cond  = 'P_C_S'. fn_cond+5  = x. ASSIGN (fn_cond)  TO &lt;fs_cond&gt;.
    fn_date  = 'P_D_S'. fn_date+5  = x. ASSIGN (fn_date)  TO &lt;fs_date&gt;.

    PERFORM pruef_step USING  x &lt;fs_repid&gt; &lt;fs_vari&gt;
                                 fn_repid   fn_vari.
  ENDDO.

*======================================================================
FORM  pruef_step USING us_x us_repid us_vari
                            fn_repid fn_vari.
*======================================================================

  DATA: line(120),
        ls_repid  TYPE program,
        ls_repidu TYPE program,
        ls_variu  LIKE wk_c30k,
        ls_vari   LIKE wk_c30k.

  CLEAR wk_actiontype+us_x(1).
  CLEAR wk_zz_me+us_x(1).

  CHECK us_repid &lt;&gt; space.

  ls_repidu = us_repid.
  TRANSLATE ls_repidu TO UPPER CASE.
  ls_variu  = us_vari.
  TRANSLATE ls_variu  TO UPPER CASE.

  ls_repid = ls_repidu.
  ls_vari  = ls_variu.

  IF ls_repid(5) = 'GR55 '.
    ls_repid(5) = 'GR55.'.
    CONDENSE ls_repid+5 NO-GAPS.
  ELSE.
    CONDENSE ls_repid NO-GAPS.
  ENDIF.
  IF ls_repid(1)   = '@'  AND
     ls_repid+3(1) = '@'.
    ls_repid      =  ls_repid+4.
    TRANSLATE us_repid+1(2) TO UPPER CASE.
  ENDIF.

  IF ls_repid(4) = 'GR55'.
    CASE ls_repid+4(1).
      WHEN '='
       OR  '-'
       OR  '_'
       OR  '.'
       OR  ','
       OR  '&gt;'
       OR  '/'.
      WHEN OTHERS. ls_repid+5 = ls_repid+4. CLEAR ls_repid+4(1).
    ENDCASE.
  ENDIF.

  IF wk_sa38_allowed = 'X'.
    SELECT SINGLE * FROM trdir WHERE name = ls_repid.
    IF sy-subrc &lt;&gt; 0.
      line      = 'Line'.
      line+5    = us_x.
      line+9    = 'Report:'.
      line+18   = ls_repid.
      line+62   = 'does not exist!'.
      CONDENSE line.
      CLEAR wk_actiontype+us_x(1).
    ELSE.
      wk_actiontype+us_x(1) = 'R'.          "Report
    ENDIF.

    IF wk_actiontype+us_x(1) = 'R' AND          "Report
       us_vari  &lt;&gt; space.
      DO 2 TIMES.
        SELECT SINGLE * FROM varid WHERE report  = ls_repid
                                    AND  variant = ls_vari.
        IF sy-subrc = 0  OR
           ls_vari+0(1) &lt;&gt; '@'.
          EXIT.
        ENDIF.
        IF  ls_vari+0(1) = '@' AND
            ls_vari+3(1) = '@'.
          ls_vari      =  ls_vari+4.
        ENDIF.
      ENDDO.

      IF sy-subrc &lt;&gt; 0.
        line      = 'Line'.
        line+5    = us_x.
        line+9    = 'Variant:'.
        line+18   = ls_vari.
        line+62   = 'does not exist!'.
        CONDENSE line.
      ELSE.
        IF varid-environmnt = 'B'.
          wk_actiontype+us_x(1) = 'H'.   "Rep. with vari for background
        ELSE.
          wk_actiontype+us_x(1) = 'V'.   "Report with variant
        ENDIF.
        us_vari = ls_variu.
      ENDIF.
    ENDIF.
  ENDIF.

  IF wk_actiontype+us_x(1) &lt;&gt; space.
    us_repid = ls_repidu.
  ENDIF.
  CHECK wk_actiontype+us_x(1) = space.

  DATA: l_repid(40).

  SELECT SINGLE * FROM tstc WHERE tcode = ls_repid.
  IF sy-subrc     &lt;&gt;  0.
    IF       ls_repid(3)  =  '/T/'.
      l_repid = ls_repid+3.
    ENDIF.
    IF l_repid &lt;&gt; space.
      SELECT SINGLE * FROM tstc WHERE tcode = l_repid.
    ENDIF.
  ENDIF.

  IF sy-subrc      =   0     AND
     tstc-pgmna(4) &lt;&gt; 'MENU'.
    wk_actiontype+us_x(1) = 'T'.        "Transaction
    us_repid = ls_repidu.
  ENDIF.

  IF wk_actiontype+us_x(1) = 'T' AND          "Transaktion
     us_vari  &lt;&gt; space.
    DO 2 TIMES.
      SELECT SINGLE * FROM varid WHERE report  = tstc-pgmna
                                  AND  variant = ls_vari.
      IF sy-subrc = 0  OR
         ls_vari+0(1) &lt;&gt; '@'.
        EXIT.
      ENDIF.
      IF  ls_vari+0(1) = '@' AND
          ls_vari+3(1) = '@'.
        ls_vari      =  ls_vari+4.
      ENDIF.
    ENDDO.

    IF sy-subrc &lt;&gt; 0.
      line      = 'Line'.
      line+5    = us_x.
      line+9    = 'Variant:'.
      line+18   = us_vari.
      line+62   = 'does not exist!'.
      CONDENSE line.
    ELSE.
      IF varid-environmnt = 'B'.
        wk_actiontype+us_x(1) = 'h'.   "Trans with vari for background
      ELSE.
        wk_actiontype+us_x(1) = 'v'.        "Transaction with variant
      ENDIF.
      us_vari = ls_variu.
    ENDIF.
  ENDIF.

  IF wk_actiontype+us_x(1) = 'T' AND          "Transaktion
     us_vari  &lt;&gt; space.
    CONDENSE ls_vari NO-GAPS.

    CASE  ls_repid.
      WHEN 'SE11'
       OR  'SE16'
       OR  'SE16N'
       OR  'SE17'
       OR  'SE54'
       OR  'SM30'
       OR  'SM31'. SELECT SINGLE * FROM dd02l WHERE tabname =  ls_vari.
        IF sy-subrc = 0.
          us_vari = ls_variu.
        ENDIF.
        WHEN 'SM34'. SELECT SINGLE * FROM vcldirt WHERE vclname = ls_vari
                                                   AND  spras   = sy-langu.
        IF sy-subrc = 0.
          us_vari = ls_variu.
        ENDIF.

        WHEN 'SE71'. SELECT SINGLE * FROM stxh WHERE tdobject = 'FORM'
                                                AND  tdname   =  ls_vari
                                                AND  tdid     = 'TXT'
                                                AND  tdspras  = sy-langu.
        IF sy-subrc = 0.
          us_vari = ls_variu.
        ENDIF.
      WHEN 'SE38'
       OR  'SA38'
       OR  'SE51'
       OR  'SE80'. SELECT SINGLE * FROM trdirt WHERE name  =  ls_vari
        AND  sprsl = sy-langu.
        IF sy-subrc &lt;&gt; 0.
          SELECT SINGLE * FROM trdirt WHERE name  =  ls_vari
                                       AND  sprsl = 'E'.
        ENDIF.
        IF sy-subrc &lt;&gt; 0.
          SELECT SINGLE * FROM trdirt WHERE name  =  ls_vari
                                       AND  sprsl = 'D'.
        ENDIF.
        IF sy-subrc = 0.
          us_vari = ls_variu.
        ENDIF.
    ENDCASE.
  ENDIF.

  IF wk_actiontype+us_x(1) = space  .
    IF ls_repid(4) = 'GR55'   AND
       ls_repid+5 &lt;&gt; space.
      IF ls_repid(5) = 'GR55=' OR
         ls_repid(5) = 'GR55-' OR
         ls_repid(5) = 'GR55_' OR
         ls_repid(5) = 'GR55.' OR
         ls_repid(5) = 'GR55,' OR
         ls_repid(5) = 'GR55&gt;' OR
         ls_repid(5) = 'GR55/'.

        PERFORM get_gr55_reportname USING us_x ls_repid us_vari
                                               fn_repid fn_vari.

        IF wk_actiontype+us_x(1) = 'B'.
          us_repid = ls_repidu.
        ENDIF.

        IF wk_actiontype+us_x(1) = 'B' AND          "Berichtsgruppe
           us_vari          &lt;&gt; space   AND
           wk_gr55_repname  &lt;&gt; space.
          DO 2 TIMES.
            SELECT SINGLE * FROM varid WHERE report  = wk_gr55_repname
                                        AND  variant = ls_vari.
            IF sy-subrc = 0  OR
               ls_vari+0(1) &lt;&gt; '@'.
              EXIT.
            ENDIF.
            IF  ls_vari+0(1) = '@' AND
                ls_vari+3(1) = '@'.
              ls_vari      =  ls_vari+4.
            ENDIF.
          ENDDO.


          IF sy-subrc &lt;&gt; 0.
            line      = 'Line'.
            line+5    = us_x.
            line+9    = 'Variant:'.
            line+18   = us_vari.
            line+62   = 'does not exist!'.
            CONDENSE line.
          ELSE.
            IF varid-environmnt = 'B'.
              wk_actiontype+us_x(1) = 'H'."Rep. with vari for background
            ELSE.
              wk_actiontype+us_x(1) = 'V'.   "Report with variant
            ENDIF.
            us_vari = ls_variu.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

* Nun kann es sich noch um eine Berichtsgruppen Transaktion handeln
* der Reportname muss hier über die Tab. TSTCP ermittelt werden.

  IF wk_actiontype+us_x(1) = 'T' AND          "Transaktion
     us_vari  &lt;&gt; space.
    PERFORM get_tstcp_reportname USING us_x ls_repid ls_variu
                                            fn_repid fn_vari.
  ENDIF.

  IF wk_actiontype+us_x(1) =  'G'.
    us_vari = ls_variu.
  ENDIF.

  IF wk_actiontype+us_x(1) = space.
    wk_actiontype+us_x(1) =  'C'.
  ENDIF.

ENDFORM.
*======================================================================
FORM get_gr55_reportname USING us_x us_repid us_vari
                                    fn_repid fn_vari.
*======================================================================
  DATA: l_generated,
        l_e30_job(4),
        l_prog_name  TYPE progname,
        l_subrc      LIKE sy-subrc.

  CLEAR wk_gr55_repname.

  IF us_repid(5) = 'GR55=' OR
     us_repid(5) = 'GR55-' OR
     us_repid(5) = 'GR55_' OR
     us_repid(5) = 'GR55.' OR
     us_repid(5) = 'GR55,' OR
     us_repid(5) = 'GR55&gt;' OR
     us_repid(5) = 'GR55/' OR
     us_repid(5) = 'GR55 '.
    l_e30_job   = us_repid+5.
  ELSE.
    l_e30_job = us_repid+4.
  ENDIF.

  SELECT * FROM t803vp WHERE rgjnr      =  l_e30_job
                        AND  progclass  = 'RW_EXECUTION'
                        ORDER BY versn DESCENDING.
    EXIT.
  ENDSELECT.

  IF sy-subrc = 0.
    CONCATENATE 'GP' t803vp-uni_idc25 sy-mandt INTO wk_gr55_repname.
    wk_actiontype+us_x(1) =  'B'.
    EXIT.
  ENDIF.

  CALL FUNCTION 'GRW_JOB_SUBMIT_PREPARE'
    EXPORTING
      i_report_group = l_e30_job
      i_program_type = 'X'
    IMPORTING
      e_subrc        = l_subrc
      e_program_name = l_prog_name
    EXCEPTIONS
      OTHERS         = 4.

  CHECK sy-subrc = 0.

  wk_actiontype+us_x(1) =  'B'.
  wk_gr55_repname = l_prog_name.

ENDFORM.
*======================================================================
FORM get_tstcp_reportname USING us_x us_repid us_vari
                                     fn_repid fn_vari.
*======================================================================
  DATA: l_generated,
        l_e30_job(4),
        l_prog_name  TYPE progname,
        l_subrc      LIKE sy-subrc,
        l_trans(40),
        l_f1(60),
        l_f2(60),
        l_f3(60).

  CLEAR wk_tstcp_repname.

  IF     us_repid(3) = '/T/'.
    l_trans = us_repid+3.
  ELSE.
    l_trans = us_repid.
  ENDIF.

  SELECT SINGLE * FROM tstc  WHERE tcode = l_trans.
  CHECK sy-subrc   = 0.
  CHECK tstc-pgmna = space.

  SELECT SINGLE * FROM tstcp WHERE tcode = l_trans.
  CHECK sy-subrc = 0.

  SPLIT tstcp-param AT ';' INTO l_f1 l_f2 l_f3.

  CHECK l_f1+27 = 'REPORTTYPE=RW'.

  l_e30_job = l_f2+19.
  SELECT * FROM t803vp WHERE rgjnr      =  l_e30_job
                        AND  progclass  = 'RW_EXECUTION'
                        ORDER BY versn DESCENDING.
    EXIT.
  ENDSELECT.

  IF sy-subrc = 0.
    CONCATENATE 'GP' t803vp-uni_idc25 sy-mandt INTO wk_tstcp_repname.
    SELECT SINGLE * FROM varid WHERE report  = wk_tstcp_repname
                                AND  variant = us_vari.
    IF sy-subrc = 0.
      wk_actiontype+us_x(1) =  'G'.
      EXIT.
    ENDIF.
    EXIT.
  ENDIF.

  CALL FUNCTION 'GRW_JOB_SUBMIT_PREPARE'
    EXPORTING
      i_report_group = l_e30_job
      i_program_type = 'X'
    IMPORTING
      e_subrc        = l_subrc
      e_program_name = l_prog_name
    EXCEPTIONS
      OTHERS         = 4.

  CHECK sy-subrc = 0.

  wk_tstcp_repname = l_prog_name.
  SELECT SINGLE * FROM varid WHERE report  = wk_tstcp_repname
                              AND  variant = us_vari.
  IF sy-subrc = 0.
    wk_actiontype+us_x(1) =  'G'.
  ENDIF.

ENDFORM.
*======================================================================

DATA: t_fields LIKE help_value OCCURS 0 WITH HEADER LINE.

DATA: BEGIN OF t_fnames OCCURS 0,
      fname(21),                      END OF t_fnames.

DATA: BEGIN OF t_abstg  OCCURS 0,
      kennzahl LIKE sy-repid,
      text     TYPE text80,      END OF t_abstg.

DATA: wk_selectionfield LIKE help_info-fieldname,
      wk_l_index        LIKE sy-tabix,
      wk_vr_titel(40).

DATA: dynpfields LIKE dynpread OCCURS 0 WITH HEADER LINE,
      li_rep     LIKE sy-repid.

DATA: wk_ff_index(5)              TYPE n,
      wk_ff_line(150),
      wk_ff_line_reset,
      wk_ff_filter_index(5)       TYPE n,
      wk_ff_num5(5)               TYPE n,
      wk_ff_nodel_t_loaded_filter,
      wk_ff_screen(4),
      wk_ff_answer,
      wk_ff_msg(60),
      wk_ff_textline1(60),
      wk_ff_textline2(60),
      wk_ff_textline3(60),
      wk_ff_text_option1(10),
      wk_ff_text_option2(10),
      wk_ff_titel(25),
      wk_ff_uname                 LIKE sy-uname,
      wk_ff_repid                 LIKE sy-repid,
      wk_ff_total_lines(6)        TYPE n,
      wk_ff_current_line(6)       TYPE n,
      wk_ff_remark_no_lines,

      wk_ff_ende2.

DEFINE macro_value_request.
  AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_v_s&amp;1.
     PERFORM show_variants CHANGING        p_v_s&amp;1.
END-OF-DEFINITION.

macro_value_request 001.
macro_value_request 002.
macro_value_request 003.
macro_value_request 004.
macro_value_request 005.
macro_value_request 006.
macro_value_request 007.
macro_value_request 008.
macro_value_request 009.
macro_value_request 010.
macro_value_request 011.
macro_value_request 012.
macro_value_request 013.
macro_value_request 014.
macro_value_request 015.
macro_value_request 016.
macro_value_request 017.
macro_value_request 018.
macro_value_request 019.
macro_value_request 020.
macro_value_request 021.
macro_value_request 022.
macro_value_request 023.
macro_value_request 024.
macro_value_request 025.
macro_value_request 026.
macro_value_request 027.
macro_value_request 028.
macro_value_request 029.
macro_value_request 030.
macro_value_request 031.
macro_value_request 032.
macro_value_request 033.
macro_value_request 034.
macro_value_request 035.
macro_value_request 036.
macro_value_request 037.
macro_value_request 038.
macro_value_request 039.
macro_value_request 040.
macro_value_request 041.
macro_value_request 042.
macro_value_request 043.
macro_value_request 044.
macro_value_request 045.
macro_value_request 046.
macro_value_request 047.
macro_value_request 048.
macro_value_request 049.

macro_value_request 050.
macro_value_request 051.
macro_value_request 052.
macro_value_request 053.
macro_value_request 054.
macro_value_request 055.
macro_value_request 056.
macro_value_request 057.
macro_value_request 058.
macro_value_request 059.
macro_value_request 060.
macro_value_request 061.
macro_value_request 062.
macro_value_request 063.
macro_value_request 064.
macro_value_request 065.
macro_value_request 066.
macro_value_request 067.
macro_value_request 068.
macro_value_request 069.
macro_value_request 070.
macro_value_request 071.
macro_value_request 072.
macro_value_request 073.
macro_value_request 074.
macro_value_request 075.
macro_value_request 076.
macro_value_request 077.
macro_value_request 078.
macro_value_request 079.
macro_value_request 080.
macro_value_request 081.
macro_value_request 082.
macro_value_request 083.
macro_value_request 084.
macro_value_request 085.
macro_value_request 086.
macro_value_request 087.
macro_value_request 088.
macro_value_request 089.
macro_value_request 090.
macro_value_request 091.
macro_value_request 092.
macro_value_request 093.
macro_value_request 094.
macro_value_request 095.
macro_value_request 096.
macro_value_request 097.
macro_value_request 098.
macro_value_request 099.

*======================================================================
FORM show_variants CHANGING l_vari.
*======================================================================
  DATA l_curr_line(3) TYPE n.

  CLEAR:   t_fields, t_fnames, t_abstg.
  REFRESH: t_fields, t_fnames, t_abstg.

  t_fnames-fname = 'VARIT-VARIANT'. APPEND t_fnames.
  t_fnames-fname = 'ZVISH-TITEL'.   APPEND t_fnames.
  wk_selectionfield = 'KENNZAHL'.

  GET CURSOR FIELD wk_cursor_field VALUE wk_field_content.

  l_curr_line  =  wk_cursor_field+5.

  fn_repid = 'P_R_S'. fn_repid+5 =  l_curr_line.
  ASSIGN (fn_repid) TO &lt;fs_repid&gt;.

  CLEAR dynpfields. REFRESH dynpfields.
  dynpfields-fieldname = fn_repid.
  APPEND dynpfields.

  wk_ff_repid = sy-repid.

  CALL FUNCTION 'DYNP_VALUES_READ'
    EXPORTING
      dyname               = wk_ff_repid
      dynumb               = '1000'
    TABLES
      dynpfields           = dynpfields
    EXCEPTIONS
      invalid_abapworkarea = 1.
  IF    sy-subrc &lt;&gt; 0.
    CLEAR li_rep.
  ELSE.
    li_rep = dynpfields-fieldvalue.
    TRANSLATE li_rep TO UPPER CASE.
  ENDIF.

  CASE wk_actiontype+l_curr_line(1).
    WHEN  'R'.
      SELECT * FROM varit WHERE langu   = sy-langu
                           AND  report  = li_rep.
        t_abstg-kennzahl = varit-variant.
        t_abstg-text     = varit-vtext.
        APPEND t_abstg.
        CLEAR  t_abstg.
      ENDSELECT.

      CONCATENATE 'Variants of report' &lt;fs_repid&gt;
             INTO  wk_vr_titel
        SEPARATED BY space.
    WHEN  'T'.
      SELECT SINGLE * FROM tstc WHERE tcode = li_rep.
      IF sy-subrc = 0.
        SELECT * FROM varit WHERE langu   = sy-langu
                             AND  report  = tstc-pgmna.
          t_abstg-kennzahl = varit-variant.
          t_abstg-text     = varit-vtext.
          APPEND t_abstg.
          CLEAR  t_abstg.
        ENDSELECT.

        CONCATENATE 'Variants of transaction' &lt;fs_repid&gt;
               INTO  wk_vr_titel
          SEPARATED BY space.
      ENDIF.
  ENDCASE.

  PERFORM display_requst_values TABLES t_abstg.

  CHECK sy-subrc = 0.
  READ TABLE t_abstg INDEX wk_l_index.
  IF sy-subrc = 0.
    MOVE t_abstg-kennzahl TO l_vari.
  ENDIF.

ENDFORM.
*======================================================================
FORM display_requst_values TABLES form_table1.
*======================================================================

  CALL FUNCTION 'TRANSFER_NAMES_TO_FIELDS'
    EXPORTING
      selectfield        = wk_selectionfield
    TABLES
      fields             = t_fields
      namelist           = t_fnames
    EXCEPTIONS
      wrong_format_given = 1
      OTHERS             = 2.
  IF sy-subrc = 0. ENDIF.

  CALL FUNCTION 'HELP_VALUES_GET_NO_DD_NAME'
    EXPORTING
      selectfield                  = wk_selectionfield
      titel                        = wk_vr_titel
    IMPORTING
      ind                          = wk_l_index
    TABLES
      fields                       = t_fields
      full_table                   = form_table1
    EXCEPTIONS
      full_table_empty             = 1
      no_tablestructure_given      = 2
      no_tablefields_in_dictionary = 3
      more_then_one_selectfield    = 4
      no_selectfield               = 5
      OTHERS                       = 6.
  IF sy-subrc = 0. ENDIF.

ENDFORM.

*======================================================================
START-OF-SELECTION.
*======================================================================
  IMPORT memory_prerep FROM MEMORY ID 'MEMORY_PREREP'.
  FREE                      MEMORY ID 'MEMORY_PREREP'.

  CHECK memory_prerep-prerep &lt;&gt; sy-repid.

  SET PF-STATUS 'LISTE'.

  IF sy-slset &lt;&gt; space.
    memory_prerep-prerep = sy-repid.
    EXPORT memory_prerep TO MEMORY ID 'MEMORY_PREREP'.
    SUBMIT (sy-repid)  VIA SELECTION-SCREEN
                       USING SELECTION-SET sy-slset  AND RETURN.
  ENDIF.

  wk_message  = '  Start of processing'.

*======================================================================
FORM open_variant.
*======================================================================
  DATA: ls_repid     TYPE program,
        ls_vari(30),
        l_vari_valid,
        l_actiontype.

  IF sy-ucomm(6) &lt;&gt; 'OPEN_S'.
    GET CURSOR FIELD wk_cursor_field VALUE wk_field_content.

    IF wk_cursor_field(5) = 'P_R_S'.
      EXIT.
    ENDIF.

    IF wk_cursor_field = space        OR
       wk_cursor_field(5) &lt;&gt; 'P_V_S'.
      MESSAGE 'Select a Variant in column "Variant"!'
              TYPE 'E'.
    ENDIF.
  ELSE.
    CONCATENATE 'P_V_' sy-ucomm+5 INTO wk_cursor_field.
  ENDIF.

  FIELD-SYMBOLS: &lt;fs_repid&gt;, &lt;fs_vari&gt;, &lt;fs_cond&gt;, &lt;fs_date&gt;.

  DATA: fn_repid(8),              " like trdir-name,
        fn_vari(8),               " like varid-variant,
        x(3)        TYPE n,

        ende.

  fn_vari       =  wk_cursor_field.  ASSIGN (fn_vari)  TO &lt;fs_vari&gt;.
  fn_repid      =  fn_vari.
  fn_repid+2(1) = 'R'.               ASSIGN (fn_repid) TO &lt;fs_repid&gt;.

  ls_repid = &lt;fs_repid&gt;.
  TRANSLATE ls_repid TO UPPER CASE.
  CONDENSE ls_repid NO-GAPS.
  IF ls_repid(1)   = '@'  AND
     ls_repid+3(1) = '@'.
    ls_repid      =  ls_repid+4.
  ENDIF.

  x = fn_vari.

  IF  ls_repid  = space.
    MESSAGE 'Report missing in current line'
            TYPE 'E'.
  ENDIF.

  IF ls_repid(4) = 'GR55'.
    CASE ls_repid+4(1).
      WHEN '='
       OR  '-'
       OR  '_'
       OR  '.'
       OR  ','
       OR  '&gt;'
       OR  '/'
       OR  ' '.
      WHEN OTHERS. ls_repid+5 = ls_repid+4. CLEAR ls_repid+4(1).
    ENDCASE.
  ENDIF.

  IF  ls_repid(5) = 'GR55=' OR
      ls_repid(5) = 'GR55-' OR
      ls_repid(5) = 'GR55_' OR
      ls_repid(5) = 'GR55.' OR
      ls_repid(5) = 'GR55,' OR
      ls_repid(5) = 'GR55&gt;' OR
      ls_repid(5) = 'GR55/' OR
      ls_repid(5) = 'GR55 '.

    l_actiontype = wk_actiontype+x(1).
    PERFORM get_gr55_reportname USING 1  ls_repid  &lt;fs_vari&gt;
                                         ls_repid  &lt;fs_vari&gt;.
    tab-rep = wk_gr55_repname.
    wk_actiontype+x(1) = l_actiontype.
  ELSE.
    PERFORM pruef_step USING  x  ls_repid  &lt;fs_vari&gt;
                                 fn_repid   fn_vari.
    tab-rep  =  ls_repid.
    IF wk_actiontype+x(1) = 'G'.
      tab-rep = wk_tstcp_repname.
    ENDIF.
  ENDIF.

  tab-vari = &lt;fs_vari&gt;.
  TRANSLATE tab-vari TO UPPER CASE.

  IF wk_actiontype+x(1) = 'v'.
    ASSIGN (tstc-pgmna) TO &lt;fs_repid&gt;.
  ELSE.
    ASSIGN (tab-rep)    TO &lt;fs_repid&gt;.
  ENDIF.

  IF wk_actiontype+x(1) = 'v'.
    ASSIGN (tstc-pgmna) TO &lt;fs_repid&gt;.
  ELSE.
    ASSIGN (tab-rep)    TO &lt;fs_repid&gt;.
  ENDIF.

  IF tab-vari+0(1) = '@' AND
     tab-vari+3(1) = '@'.
    SELECT SINGLE * FROM varid WHERE report  = &lt;fs_repid&gt;
                                AND  variant = &lt;fs_vari&gt;.
    IF sy-subrc &lt;&gt; 0.
      tab-vari = tab-vari+4.
    ENDIF.
  ENDIF.

  CASE wk_actiontype+x(1).
    WHEN 'R'
     OR  'B'.  SUBMIT (tab-rep)   VIA SELECTION-SCREEN          AND RETURN.
    WHEN 'V'
     OR  'G'
     OR  'H'.  SUBMIT (tab-rep)   VIA SELECTION-SCREEN
      USING SELECTION-SET tab-vari  AND RETURN.
    WHEN 'v'
     OR  'h'.  SUBMIT (tstc-pgmna)  VIA SELECTION-SCREEN
      USING SELECTION-SET tab-vari  AND RETURN.
  ENDCASE.

  ls_vari  =  &lt;fs_vari&gt;.

  CASE wk_actiontype+x(1).
    WHEN 'T'.
      IF ls_vari+0(1) = '@' AND
         ls_vari+3(1) = '@'.
        ls_vari = ls_vari+4.
      ENDIF.
      CONDENSE ls_vari NO-GAPS.
      CASE  ls_repid.
        WHEN 'SE11'
         OR  'SE16'
         OR  'SE16N'
         OR  'SE17'
         OR  'SE54'
         OR  'SM30'
         OR  'SM31'.
          IF &lt;fs_vari&gt;  &lt;&gt; space.
            SELECT SINGLE * FROM dd02l WHERE tabname =  ls_vari.
            IF sy-subrc = 0.
              l_vari_valid = 'X'.
              CASE  ls_repid.
                WHEN 'SE11'
                 OR  'SE16'
                 OR  'SE16N'
                 OR  'SE17'. SET PARAMETER ID 'DTB' FIELD  ls_vari.
                WHEN 'SM30'
                 OR  'SM31'
                 OR  'SE54'. SET PARAMETER ID 'DVI' FIELD  ls_vari.
              ENDCASE.
            ENDIF.
          ENDIF.
        WHEN 'SM34'.  SET PARAMETER ID 'VCL' FIELD  ls_vari.
        WHEN 'SE71'.  SET PARAMETER ID 'TXF' FIELD  ls_vari.
        WHEN 'SE37'.  SET PARAMETER ID 'LIB' FIELD  ls_vari.
        WHEN 'SA38'
         OR  'SE38'
         OR  'SE80'.  SET PARAMETER ID 'RID' FIELD  ls_vari.
          IF ls_repid = 'SA38'.
            IF sy-subrc = 0.
              l_vari_valid = 'X'.
            ENDIF.
          ENDIF.
        WHEN 'SE51'.  SET PARAMETER ID 'DYR' FIELD  ls_vari.
      ENDCASE.

      DATA l_trans LIKE tstc-tcode.

      IF     tab-rep(3) = '/T/'.
        l_trans = tab-rep+3.
      ELSE.
        l_trans = tab-rep.
      ENDIF.

      SET CURSOR FIELD fn_repid.
      CALL FUNCTION 'AUTHORITY_CHECK_TCODE'
        EXPORTING
          tcode  = l_trans
        EXCEPTIONS
          ok     = 1
          not_ok = 2
          OTHERS = 3.

      IF sy-subrc &gt; 1.
        SET CURSOR FIELD fn_repid.
        CONCATENATE 'No authority for transaction: '
                     l_trans
                     INTO wk_message
           SEPARATED BY space.
        MESSAGE wk_message
                TYPE 'I'.
      ELSE.
        IF    l_vari_valid = 'X'.
          CALL TRANSACTION l_trans AND SKIP FIRST SCREEN.
        ELSE.
          CALL TRANSACTION l_trans.
        ENDIF.
      ENDIF.
      EXIT.
  ENDCASE.

ENDFORM.
*======================================================================
FORM submit_variant.
*======================================================================
  DATA: ls_repid     TYPE program,
        ls_vari(30),
        l_vari_valid,
        l_actiontype.

  IF sy-ucomm(6) &lt;&gt; 'SUBM_S'.
    GET CURSOR FIELD wk_cursor_field VALUE wk_field_content.

    IF wk_cursor_field = space        OR
       wk_cursor_field(5) &lt;&gt; 'P_V_S'.
      MESSAGE 'Select a Variant in column "Variant"!'
              TYPE 'E'.
    ENDIF.
  ELSE.
    CONCATENATE 'P_V_' sy-ucomm+5 INTO wk_cursor_field.
  ENDIF.

  FIELD-SYMBOLS: &lt;fs_repid&gt;, &lt;fs_vari&gt;, &lt;fs_cond&gt;, &lt;fs_date&gt;.

  DATA: fn_repid(8),              " like trdir-name,
        fn_vari(8),               " like varid-variant,
        x(3)        TYPE n,
        ende.

  fn_vari       =  wk_cursor_field.  ASSIGN (fn_vari)  TO &lt;fs_vari&gt;.
  fn_repid      =  fn_vari.
  fn_repid+2(1) = 'R'.               ASSIGN (fn_repid) TO &lt;fs_repid&gt;.

  ls_repid = &lt;fs_repid&gt;.
  TRANSLATE ls_repid TO UPPER CASE.
  CONDENSE ls_repid NO-GAPS.
  IF ls_repid(1)   = '@'  AND
     ls_repid+3(1) = '@'.
    ls_repid      =  ls_repid+4.
  ENDIF.

  ls_vari  =  &lt;fs_vari&gt;.
  TRANSLATE ls_vari TO UPPER CASE.

  x = fn_vari.

  IF &lt;fs_repid&gt; = space.
    MESSAGE 'Report missing in current line'
            TYPE 'I'.
  ENDIF.

  IF ls_repid(4) = 'GR55' AND
     ls_repid+5 &lt;&gt;  space.
    l_actiontype = wk_actiontype+x(1).
    PERFORM get_gr55_reportname USING 1  ls_repid  &lt;fs_vari&gt;
                                         ls_repid  &lt;fs_vari&gt;.
    tab-rep = wk_gr55_repname.
    wk_actiontype+x(1) = l_actiontype.
  ELSE.
    PERFORM pruef_step USING  x  ls_repid   ls_vari
                                 fn_repid   fn_vari.

    tab-rep  =  ls_repid.
    IF wk_actiontype+x(1) = 'G'.
      tab-rep = wk_tstcp_repname.
    ENDIF.
  ENDIF.

  tab-vari = &lt;fs_vari&gt;.

  CASE wk_actiontype+x(1).
    WHEN 'T'.
      IF ls_vari+0(1) = '@' AND
         ls_vari+3(1) = '@'.
        ls_vari = ls_vari+4.
      ENDIF.
      CONDENSE ls_vari NO-GAPS.
      CASE  ls_repid.
        WHEN 'SE11'
         OR  'SE16'
         OR  'SE16N'
         OR  'SE17'
         OR  'SE54'
         OR  'SM30'
         OR  'SM31'.
          IF &lt;fs_vari&gt;  &lt;&gt; space.
            SELECT SINGLE * FROM dd02l WHERE tabname =  ls_vari.
            IF sy-subrc = 0.
              l_vari_valid = 'X'.
              CASE  ls_repid.
                WHEN 'SE11'
                 OR  'SE16'
                 OR  'SE16N'
                 OR  'SE17'. SET PARAMETER ID 'DTB' FIELD  ls_vari.
                WHEN 'SM30'
                 OR  'SM31'
                 OR  'SE54'. SET PARAMETER ID 'DVI' FIELD  ls_vari.
              ENDCASE.
            ENDIF.
          ENDIF.
        WHEN 'SM34'.  SET PARAMETER ID 'VCL' FIELD  ls_vari.
        WHEN 'SE71'.  SET PARAMETER ID 'TXF' FIELD  ls_vari.
        WHEN 'SE37'.  SET PARAMETER ID 'LIB' FIELD  ls_vari.
        WHEN 'SA38'
         OR  'SE38'
         OR  'SE80'.  SET PARAMETER ID 'RID' FIELD  ls_vari.
          IF ls_repid = 'SA38'.
            IF sy-subrc = 0.
              l_vari_valid = 'X'.
            ENDIF.
          ENDIF.
        WHEN 'SE51'.  SET PARAMETER ID 'DYR' FIELD  ls_vari.
      ENDCASE.

      DATA l_trans LIKE tstc-tcode.

      IF     tab-rep(3) = '/T/'.
        l_trans = tab-rep+3.
      ELSE.
        l_trans = tab-rep.
      ENDIF.

      SET CURSOR FIELD fn_repid.
      CALL FUNCTION 'AUTHORITY_CHECK_TCODE'
        EXPORTING
          tcode  = l_trans
        EXCEPTIONS
          ok     = 1
          not_ok = 2
          OTHERS = 3.

      IF sy-subrc &gt; 1.
        SET CURSOR FIELD fn_repid.
        CONCATENATE 'No authority for transaction: '
                     l_trans
                     INTO wk_message
           SEPARATED BY space.
        MESSAGE wk_message
                TYPE 'I'.
      ELSE.
        IF    l_vari_valid = 'X'.
          CALL TRANSACTION l_trans AND SKIP FIRST SCREEN.
        ELSE.
          CALL TRANSACTION l_trans.
        ENDIF.
      ENDIF.
      EXIT.
  ENDCASE.

  IF wk_actiontype+x(1) = 'v'.
    ASSIGN (tstc-pgmna) TO &lt;fs_repid&gt;.
  ELSE.
    ASSIGN (tab-rep)    TO &lt;fs_repid&gt;.
  ENDIF.

  IF tab-vari+0(1) = '@' AND
     tab-vari+3(1) = '@'.
    SELECT SINGLE * FROM varid WHERE report  = &lt;fs_repid&gt;
                                AND  variant = &lt;fs_vari&gt;.
    IF sy-subrc &lt;&gt; 0.
      tab-vari = tab-vari+4.
    ENDIF.
  ENDIF.

  CASE wk_actiontype+x(1).
    WHEN 'V'
     OR  'R'
     OR  'G'.
      IF &lt;fs_vari&gt; = space.
        SUBMIT (tab-rep)   AND RETURN.
      ELSE.
        SUBMIT (tab-rep)   USING SELECTION-SET tab-vari  AND RETURN.
      ENDIF.

    WHEN 'v'.
      SUBMIT (tstc-pgmna)   USING SELECTION-SET tab-vari  AND RETURN.
    WHEN 'H'
     OR  'H'.
      CONCATENATE 'Variant &gt;'
                  tab-vari
                  '&lt; has flag "Only for Background Processing'
             INTO wk_message
             SEPARATED BY space.

      MESSAGE wk_message
              TYPE 'I'.

  ENDCASE.

*=======================================================================
* Direkt als Job ausführen
*=======================================================================
*
* http://www.abapforum.com/forum/viewtopic.php?t=2472 / 27.11.2004
*
* Henry fragt zuerst und liefert dann später auch die Antwort
*
* Ich möchte eine Report aus der Selektionmaske heraus im Hintergrund
* starten. Der Ablauf sollte ohne die SAP Standardfunktionalität "F9"
* erfolgen.
*
*falls jemand schon mal das Problem hatte hier eine Lösung die ich
* herausgefunden habe:
*
* 1) Aktuelle Selektionparameter holen mit
*    FUBA CALL FUNCTION 'RS_REFRESH_FROM_SELECTOPTIONS'
*
* 2) Job Öffnen
*    CALL FUNCTION 'JOB_OPEN'
*
* 3) Report für Job definieren
*    SUBMIT (l_report) VIA SELECTION-SCREEN
*                      VIA JOB l_job NUMBER l_jobnum
*                      WITH SELECTION-TABLE l_selopt   AND RETURN.
*
* 4) Job abschließen
*    CALL FUNCTION 'JOB_CLOSE'
*
* Fubktioniert einwandfrei und es lassen sich auch noch Option für
* Jobdatum/-Zeit mitgeben.
*
* Allerdings wäre es für andere Einsatzzwecke manchmal sehr hilfreich,
* trotzdem das aktuelle Selektionbild (u.U. mit verschiedenen Tabstrips)
* als Variante direkt ohne den SAP Standard-Popup speichern zu können.
* Also falls hierzu jemand was weiß, wäre ich für Hilfe sehr dankbar.
*
* Henry hfahrian
*
* ForumUser
* Beiträge: 33 Registriert: 15.11.2004, 11:10
* Wohnort: Frankenland   Dank erhalten: 0 mal
*

ENDFORM.
*======================================================================
FORM toggle_field.
*======================================================================
  DATA:  l_pos(3) TYPE n.

  GET CURSOR FIELD wk_cursor_field VALUE wk_field_content.

  CHECK wk_cursor_field+4 &lt;&gt; 'TOGL'.

  LOOP AT SCREEN.
    IF screen-group1 = 'ND2'.
      screen-invisible   = '0'.
      screen-input       = '1'.
      screen-output      = '1'.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.

  l_pos = wk_cursor_field+5.

  CASE wk_cursor_field(4).
    WHEN 'PM_C'.
      IF    p_c_togl+l_pos(1) = space.
        p_c_togl+l_pos(1) = 'X'.
      ELSE.
        p_c_togl+l_pos(1) = ' '.
      ENDIF.
    WHEN 'P_R_'.
      IF    p_r_togl+l_pos(1) = space.
        p_r_togl+l_pos(1) = 'X'.
      ELSE.
        p_r_togl+l_pos(1) = ' '.
      ENDIF.
    WHEN 'P_V_'.
      IF    p_v_togl+l_pos(1) = space.
        p_v_togl+l_pos(1) = 'X'.
      ELSE.
        p_v_togl+l_pos(1) = ' '.
      ENDIF.
    WHEN 'P_I_'.
      IF    p_i_togl+l_pos(1) = space.
        p_i_togl+l_pos(1) = 'X'.
      ELSE.
        p_i_togl+l_pos(1) = ' '.
      ENDIF.
  ENDCASE.

  LOOP AT SCREEN.
    CHECK screen-name = wk_cursor_field.
    l_pos = screen-name+5.

    CASE wk_cursor_field(4).
      WHEN 'PM_C'.
        IF    p_c_togl+l_pos(1) = space.
          screen-input = '1'.
        ELSE.
          screen-input = '0'.
        ENDIF.
      WHEN 'PM_R'.
        IF    p_r_togl+l_pos(1) = space.
          screen-input = '1'.
        ELSE.
          screen-input = '0'.
        ENDIF.
      WHEN 'PM_V'.
        IF    p_v_togl+l_pos(1) = space.
          screen-input = '1'.
        ELSE.
          screen-input = '0'.
        ENDIF.
      WHEN 'PM_I'.
        IF    p_i_togl+l_pos(1) = space.
          screen-input = '1'.
        ELSE.
          screen-input = '0'.
        ENDIF.
    ENDCASE.
    MODIFY SCREEN.
  ENDLOOP.

ENDFORM.
*======================================================================
FORM insert_line.
*======================================================================
  DATA: wk_curr_line(3)    TYPE n,
        wk_last_line(3)    TYPE n VALUE 99,
        wk_beflast_line(3) TYPE n VALUE 98,
        wk_insert_possible,
        wk_successful.

  FIELD-SYMBOLS: &lt;fs_repid&gt;,  &lt;fs_vari&gt;,  &lt;fs_cond&gt;,  &lt;fs_date&gt;,
                 &lt;fs_fromu&gt;,  &lt;fs_comm&gt;,

                 &lt;fs_prepid&gt;, &lt;fs_pvari&gt;, &lt;fs_pcond&gt;, &lt;fs_pdate&gt;,
                 &lt;fs_pfromu&gt;, &lt;fs_pcomm&gt;,

                 &lt;fs_nrepid&gt;, &lt;fs_nvari&gt;, &lt;fs_ncond&gt;, &lt;fs_ndate&gt;,
                 &lt;fs_nfromu&gt;, &lt;fs_ncomm&gt;.

  DATA: fn_repid(8),              " like trdir-name,
        fn_vari(8),               " like varid-variant,
        fn_fromu(8),
        fn_comm(8),

        fn_prepid(8),              " like trdir-name,
        fn_pvari(8),               " like varid-variant,
        fn_pfromu(8),
        fn_pcomm(8),

        fn_nrepid(8),              " like trdir-name,
        fn_nvari(8),               " like varid-variant,
        fn_nfromu(8),
        fn_ncomm(8).

  GET CURSOR FIELD wk_cursor_field VALUE wk_field_content.

  IF wk_cursor_field(2) &lt;&gt; 'P_'.
    MESSAGE 'Position your cursor on a STEP line!'
            TYPE 'E'.
  ENDIF.

  IF wk_cursor_field+5 = '099'.
    MESSAGE 'Insert on last line not possible!'
            TYPE 'E'.
  ENDIF.

  wk_curr_line  =  wk_cursor_field+5.

  DO 99 TIMES.
    IF wk_beflast_line &lt; wk_curr_line.
      EXIT.
    ENDIF.

    fn_repid = 'P_R_S'. fn_repid+5 = wk_last_line.
    ASSIGN (fn_repid) TO &lt;fs_repid&gt;.
    fn_vari  = 'P_V_S'. fn_vari+5  = wk_last_line.
    ASSIGN (fn_vari)  TO &lt;fs_vari&gt;.
    fn_comm  = 'P_I_S'. fn_comm+5  = wk_last_line.
    ASSIGN (fn_comm)  TO &lt;fs_comm&gt;.

    IF &lt;fs_repid&gt; = space      AND
       &lt;fs_vari&gt;  = space      AND
       &lt;fs_comm&gt;  = space      AND
       p_r_togl+wk_last_line(1) = space AND
       p_v_togl+wk_last_line(1) = space AND
       p_i_togl+wk_last_line(1) = space.
      wk_insert_possible = 'X'.
    ELSE.
      SUBTRACT 1 FROM wk_last_line.
      SUBTRACT 1 FROM wk_beflast_line.
      CONTINUE.
    ENDIF.

    fn_prepid = 'P_R_S'. fn_prepid+5 = wk_beflast_line.
    ASSIGN (fn_prepid) TO &lt;fs_prepid&gt;.
    fn_pvari  = 'P_V_S'. fn_pvari+5  = wk_beflast_line.
    ASSIGN (fn_pvari)  TO &lt;fs_pvari&gt;.
    fn_pcomm  = 'P_I_S'. fn_pcomm+5  = wk_beflast_line.
    ASSIGN (fn_pcomm)  TO &lt;fs_pcomm&gt;.

    IF &lt;fs_prepid&gt; =  space      AND
       &lt;fs_pvari&gt;  =  space      AND
       &lt;fs_pcomm&gt;  =  space      AND
       p_r_togl+wk_beflast_line(1)  = ' ' AND
       p_v_togl+wk_beflast_line(1)  = ' ' AND
       p_i_togl+wk_beflast_line(1)  = ' '.
      SUBTRACT 1 FROM wk_last_line.
      SUBTRACT 1 FROM wk_beflast_line.
      CONTINUE.
    ENDIF.

    MOVE &lt;fs_prepid&gt; TO &lt;fs_repid&gt;. CLEAR &lt;fs_prepid&gt;.
    MOVE &lt;fs_pvari&gt;  TO &lt;fs_vari&gt;.  CLEAR &lt;fs_pvari&gt;.
    MOVE &lt;fs_pcomm&gt;  TO &lt;fs_comm&gt;.  CLEAR &lt;fs_pcomm&gt;.

    MOVE  p_r_togl+wk_beflast_line(1) TO p_r_togl+wk_last_line(1).
    CLEAR p_r_togl+wk_beflast_line(1).
    MOVE  p_v_togl+wk_beflast_line(1) TO p_v_togl+wk_last_line(1).
    CLEAR p_v_togl+wk_beflast_line(1).
    MOVE  p_i_togl+wk_beflast_line(1) TO p_i_togl+wk_last_line(1).
    CLEAR p_i_togl+wk_beflast_line(1).

    wk_successful = 'X'.

    SUBTRACT 1 FROM wk_last_line.
    SUBTRACT 1 FROM wk_beflast_line.

  ENDDO.

ENDFORM.
*======================================================================
FORM delete_line.
*======================================================================
  DATA: wk_curr_line(3)    TYPE n,
        wk_last_line(3)    TYPE n VALUE 99,
        wk_next_line(3)    TYPE n VALUE 1,
        wk_beflast_line(3) TYPE n VALUE 98,
        wk_do_line(3)      TYPE n,
        wk_insert_possible,
        wk_successful.

  FIELD-SYMBOLS: &lt;fs_repid&gt;,  &lt;fs_vari&gt;,  &lt;fs_cond&gt;,  &lt;fs_date&gt;,
                 &lt;fs_fromu&gt;,  &lt;fs_comm&gt;,

                 &lt;fs_prepid&gt;, &lt;fs_pvari&gt;, &lt;fs_pcond&gt;, &lt;fs_pdate&gt;,
                 &lt;fs_pfromu&gt;, &lt;fs_pcomm&gt;,

                 &lt;fs_nrepid&gt;, &lt;fs_nvari&gt;, &lt;fs_ncond&gt;, &lt;fs_ndate&gt;,
                 &lt;fs_nfromu&gt;, &lt;fs_ncomm&gt;.

  DATA: fn_repid(8),              " like trdir-name,
        fn_vari(8),               " like varid-variant,
        fn_cond(8),
        fn_date      LIKE sy-datum,
        fn_fromu(8),
        fn_comm(8),

        fn_prepid(8),              " like trdir-name,
        fn_pvari(8),               " like varid-variant,
        fn_pcond(8),
        fn_pdate     LIKE sy-datum,
        fn_pfromu(8),
        fn_pcomm(8),

        fn_nrepid(8),              " like trdir-name,
        fn_nvari(8),               " like varid-variant,
        fn_ncond(8),
        fn_ndate     LIKE sy-datum,
        fn_nfromu(8),
        fn_ncomm(8).

  GET CURSOR FIELD wk_cursor_field VALUE wk_field_content.

  IF wk_cursor_field(2) &lt;&gt; 'P_'.
    MESSAGE 'Position your cursor on a STEP line!'
            TYPE 'E'.
  ENDIF.

  wk_curr_line  =  wk_cursor_field+5.

  DO 99 TIMES.
    ADD 1 TO wk_do_line.
    ADD 1 TO wk_next_line.
    IF wk_do_line &lt; wk_curr_line.
      CONTINUE.
    ENDIF.

    IF wk_next_line &lt; 100.
      fn_repid = 'P_R_S'. fn_repid+5 =  wk_next_line.
      ASSIGN (fn_repid) TO &lt;fs_repid&gt;.
      fn_vari  = 'P_V_S'. fn_vari+5  =  wk_next_line.
      ASSIGN (fn_vari)  TO &lt;fs_vari&gt;.
      fn_comm  = 'P_I_S'. fn_comm+5  =  wk_next_line.
      ASSIGN (fn_comm)  TO &lt;fs_comm&gt;.
    ENDIF.

    fn_prepid = 'P_R_S'. fn_prepid+5 = wk_do_line.
    ASSIGN (fn_prepid) TO &lt;fs_prepid&gt;.
    fn_pvari  = 'P_V_S'. fn_pvari+5  = wk_do_line.
    ASSIGN (fn_pvari)  TO &lt;fs_pvari&gt;.
    fn_pcomm  = 'P_I_S'. fn_pcomm+5  = wk_do_line.
    ASSIGN (fn_pcomm)  TO &lt;fs_pcomm&gt;.

    IF wk_do_line &lt; 99.
      MOVE &lt;fs_repid&gt; TO &lt;fs_prepid&gt;.
      MOVE &lt;fs_vari&gt;  TO &lt;fs_pvari&gt;.
      MOVE &lt;fs_comm&gt;  TO &lt;fs_pcomm&gt;.

      MOVE  p_r_togl+wk_next_line(1) TO p_r_togl+wk_do_line(1).
      CLEAR p_r_togl+wk_next_line(1).
      MOVE  p_v_togl+wk_next_line(1) TO p_v_togl+wk_do_line(1).
      CLEAR p_v_togl+wk_next_line(1).
      MOVE  p_i_togl+wk_next_line(1) TO p_i_togl+wk_do_line(1).
      CLEAR p_i_togl+wk_next_line(1).
    ENDIF.

    IF wk_next_line = 99.
      CLEAR &lt;fs_repid&gt;.
      CLEAR &lt;fs_vari&gt;.
      CLEAR &lt;fs_comm&gt;.
    ENDIF.

    wk_successful = 'X'.
  ENDDO.

ENDFORM.
*======================================================================
FORM clear_screen.
*======================================================================
  FIELD-SYMBOLS: &lt;fs_clr_screen&gt;.

  LOOP AT SCREEN.
    CHECK screen-name(4) &lt;&gt; 'TEXT'.
    CHECK screen-invisible = 0.
    CHECK screen-active    = 1.
    CHECK screen-group1(2) &lt;&gt; 'PB'.
    ASSIGN (screen-name) TO &lt;fs_clr_screen&gt;.
    CHECK &lt;fs_clr_screen&gt; &lt;&gt; space.
    CLEAR &lt;fs_clr_screen&gt;.
  ENDLOOP.

ENDFORM.</pre>
<p>&nbsp;</p>
<p>Der Beitrag <a href="/blog/persoenliches-favoriten-menue/">Persönliches Favoriten-Menü</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Pflegeview mit Datennavigation</title>
		<link>/blog/pflegeview-mit-datennavigation/</link>
		
		<dc:creator><![CDATA[Enno Wulff]]></dc:creator>
		<pubDate>Mon, 23 Apr 2018 19:08:50 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[Reports]]></category>
		<category><![CDATA[Tabellenpflegedialog]]></category>
		<category><![CDATA[Dynamische Programmierung]]></category>
		<category><![CDATA[ABAP OO]]></category>
		<guid isPermaLink="false">https://tricktresor.com/?p=1018434</guid>

					<description><![CDATA[<p>Pflegeviews kennt jeder. Sie werden zu einer Tabelle oder einem View generiert und erlauben eine mehr oder weniger komfortable Dateneingabe. Mit Pflegeviews sind die meisten Customizingfunktionen realisiert worden. Da der Tabellenpflegedialog generiert wird und von SAP seit Jahren nicht weiterentwickelt wird &#8211; ich hätte eine Menge einfacher Verbesserungsvorschläge &#8211; muss man mit dem Leben, was vorhanden ist. Die Eingabe oder die Funktionen können durch Zeitpunkte angepasst werden. Ab einer bestimmten Größe, also wenn ziemlich viele...</p>
<p>Der Beitrag <a href="/blog/pflegeview-mit-datennavigation/">Pflegeview mit Datennavigation</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Pflegeviews kennt jeder. Sie werden zu einer Tabelle oder einem View generiert und erlauben eine mehr oder weniger komfortable Dateneingabe. Mit Pflegeviews sind die meisten Customizingfunktionen realisiert worden.</p>
<p>Da der Tabellenpflegedialog generiert wird und von SAP seit Jahren nicht weiterentwickelt wird &#8211; ich hätte eine Menge einfacher Verbesserungsvorschläge &#8211; muss man mit dem Leben, was vorhanden ist. Die Eingabe oder die Funktionen können durch <a href="https://tricktresor.com/blog/zeitpunkte/">Zeitpunkte </a>angepasst werden.</p>
<p>Ab einer bestimmten Größe, also wenn ziemlich viele Schlüsselfelder vorhanden sind, wird die Eingabe und die Kontrolle der vorhandenen Daten sehr mühselig.</p>
<h2>Datennavigation</h2>
<p>Um die Daten besser sichten zu können und sozusagen durch die Daten surfen zu können, hatte ich die Idee, einen ganz bestimmten Tree-Control anzubinden, der die Daten hierarchisch darstellt. Die Darstellung der Daten funktioniert natürlich mit allen Tree-Arten, aber es gibt eine Klasse, die eine ganz besondere <em>Fähigkeit</em> hat: Bei der Klasse CL_GUI_ALV_TREE_SIMPLE kann die Hierarchie zur Laufzeit geändert werden.</p>
<p>Der Anwender kann sich so also eine ganz eigene Sicht auf die Tabelle zusammenklicken. Ein Klick auf den entsprechenden Knoten soll dann die SM30 aufrufen. Die Anzeige wird auf die Daten eingeschränkt, die durch die Hierarchie gegeben sind.</p>
<p>Um das Ganze zu verdeutlichen, habe ich eine Demotabelle mit vielen Schlüsselfeldern gebaut und ein paar fiktive Daten eingefügt. Die Tabelle stellt eine typische Customizingtabelle dar, wo zu einer bestimmten Kombination von organisatorischen Werten Optionen aktiv sind oder nicht:</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2018/04/sm30-06.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-1018440" src="https://tricktresor.com/wp-content/uploads/2018/04/sm30-06.png" alt="" width="453" height="277" srcset="/wp-content/uploads/2018/04/sm30-06.png 453w, /wp-content/uploads/2018/04/sm30-06-300x183.png 300w" sizes="(max-width: 453px) 100vw, 453px" /></a></p>
<p>Wenn man sich hier mit ein paar tausend Einträgen, die durchaus realistisch sind, zurecht finden möchte, dann braucht man schon etwas Geduld und Wissen, wie man die einzelnen Einträge Filtern kann.</p>
<h2>Vorbereitung</h2>
<p>Um die Daten zu lesen und anzeigen zu können, musste ich zwei grundsätzliche Dinge tun, die, wenn man weiß wie, nicht schwer sind:</p>
<ul>
<li>Erzeugen einer Tabelle mit genau der Struktur der vorgegebenen Tabelle</li>
<li>Daten zu einer beliebigen Tabelle/ View lesen</li>
</ul>
<h3>Dynamisch Tabelle erzeugen</h3>
<p>Das Erzeugen der Tabelle geht extrem einfach:</p>
<pre class="lang:abap decode:true ">DATA mr_data TYPE REF TO data.
FIELD-SYMBOLS &lt;lt_data&gt; TYPE STANDARD TABLE.
CREATE DATA mr_data TYPE STANDARD TABLE OF (tabellenname).
ASSIGN mr_data-&gt;* TO &lt;lt_data&gt;.</pre>
<p>In TABELLENNAME steht der Name des Views. Im Feldsymbol &lt;LT_DATA&gt; steht nun die Tabelle zur Verfügung, die genau die gleichen Eigenschaften hat, als hätte ich sie direkt im Programm angegeben:</p>
<pre class="lang:abap decode:true ">DATA lt_data TYPE STANDARD TABLE OF tabellenname.</pre>
<h3>Viewdaten lesen</h3>
<p>Wenn es sich um eine Tabelle handelt, dann kann ich die Daten einfach mit SELECT ermitteln. Bei einem Tabellenpflegeview geht das nicht. Dieser ist nur für die Verwendung in der SM30 gedacht, nicht für die Datenselektion.</p>
<p>Aber das Problem hatte wohl vor mir auch schon jemand und hat den Funktionsbaustein VIEW_GET_DATA geschrieben.</p>
<pre class="lang:abap decode:true ">    CALL FUNCTION 'VIEW_GET_DATA'
      EXPORTING
        view_name = tabellenname
      TABLES
        data      = &lt;lt_data&gt;
      EXCEPTIONS
        OTHERS    = 6.</pre>
<p>Die Selektion der Daten ist also auch kein Problem.</p>
<h2>Klasse CL_GUI_ALV_TREE_SIMPLE</h2>
<p>Kommen wir nun zu dem spannenden Teil und meiner eigentlichen Idee zur Navigation in den Daten. Die Darstellung der Daten aus dem Tabellenpflegeview möchte ich hierarchisch darstellen. Die Klasse CL_GUI_ALV_SIMPLE_TREE erstellt die Hierarchie fast automatisch.</p>
<p>Die Klasse benötigt eine Tabelle und eine Information, nach welchen Tabellenfeldern der Aufriss erfolgen soll. Wie bereits erwähnt, hat die Klasse CL_GUI_ALV_TREE_SIMPLE die besondere Eigenschaft, dass der Aufriss zur Laufzeit geändert werden kann:</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2018/04/sm30-05.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-1018435" src="https://tricktresor.com/wp-content/uploads/2018/04/sm30-05.png" alt="" width="315" height="144" srcset="/wp-content/uploads/2018/04/sm30-05.png 315w, /wp-content/uploads/2018/04/sm30-05-300x137.png 300w" sizes="(max-width: 315px) 100vw, 315px" /></a></p>
<p>Wie bei einem normalen ALV üblich, kann das Layout auch gespeichert werden, so dass man sich häufig genutzte Hierarchien speichern und wieder laden kann.</p>
<h2>Navigation</h2>
<p>Nun ist die bloße Anzeige der Daten nicht sonderlich hilfreich. Deswegen habe ich einen Doppelklick auf die Knoten und Items des Baumes programmiert. Mit einem Doppelklick sollen die Daten bis zu dieser Hierarchiestufe angezeigt werden. Wenn ich also einen Doppelklick auf die oberste Ebene, die Verkaufsorganisation 1000 mache, dann sollen im View nur die Daten mit Verkaufsorganisation 1000 angezeigt werden. Wenn ich einen Doppelklick auf den untergeordneten Vertriebsweg 10 mache, sollen nur die Daten von VkOrg 1000 und Vertriebsweg 10 angezeigt werden:</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2018/04/sm30-03.png"><img loading="lazy" decoding="async" class="alignnone size-large wp-image-1018437" src="https://tricktresor.com/wp-content/uploads/2018/04/sm30-03.png" alt="" width="640" height="278" srcset="/wp-content/uploads/2018/04/sm30-03.png 982w, /wp-content/uploads/2018/04/sm30-03-300x130.png 300w, /wp-content/uploads/2018/04/sm30-03-768x334.png 768w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>Das funktioniert auch ganz gut, denn den Tabellenpflegedialog kann man nicht nur über die Transaktion SM30 aufrufen, sondern auch über den Funktionsbaustein VIEW_MAINTENANCE_CALL. Diesem Funktionsbaustein gibt man grob die folgenden Daten mit:</p>
<ul>
<li>Tabellenname</li>
<li>Aktion (Anzeige oder Ändern)</li>
<li>Selektionstabelle</li>
</ul>
<p>Der Clou hierbei ist die Selektionstabelle, in der ich anhand der jeweiligen Doppelklick-Position im Baum genau die zugrunde liegenden Daten übergebe. Beim Doppelklick werden folgende beiden Werte geliefert:</p>
<ul>
<li>Die Hierarchiestufe</li>
<li>Der Tabellenindex der zugrunde liegenden Datentabelle</li>
</ul>
<p>Ich ermittele dafür beim Doppelklick die aktuelle Hierarchiedefinition, lese den zugrunde liegenden Tabelleneintrag und nehme dann die Werte aus der aktuellen Hierarchiestufe in die Selektionstabelle auf.</p>
<h3>Beispiel</h3>
<p>Obige Hierarchie zeigt</p>
<ul>
<li>Verkaufsorganisation
<ul>
<li>Vertriebsweg
<ul>
<li>Sparte</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Ich mache einen Doppelklick auf den Eintrag Vertriebsweg 10 der VkOrg 1000. Das Doppelklickereignis des Trees sagt mir als Hierarchiestufe VTWEG und Tabellenzeile 2.</p>
<p>Ich mache einen Loop über die aktuelle Hierarchie und weise per ASSIGN COMPONENT dieses Feld der Tabellenzeile einem weiteren Feldsymbol zu. Den Feldnamen und den Wert dieses Feldes wird an die Selektionstabelle angehängt. So lange, bis ich die aktuelle Hierarchiestufe erreicht habe.</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2018/04/sm30-01.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-1018439" src="https://tricktresor.com/wp-content/uploads/2018/04/sm30-01.png" alt="" width="981" height="575" srcset="/wp-content/uploads/2018/04/sm30-01.png 981w, /wp-content/uploads/2018/04/sm30-01-300x176.png 300w, /wp-content/uploads/2018/04/sm30-01-768x450.png 768w, /wp-content/uploads/2018/04/sm30-01-193x112.png 193w" sizes="(max-width: 981px) 100vw, 981px" /></a></p>
<h2>Hierarchie ändern</h2>
<p>Wenn ich nun nicht über die Verkaufsorganisation an die Daten ran möchte, sondern zum Beispiel über das Material, dann kann ich einfach die Hierarchie ändern:</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2018/04/sm30-02.png"><img loading="lazy" decoding="async" class="alignnone size-large wp-image-1018438" src="https://tricktresor.com/wp-content/uploads/2018/04/sm30-02.png" alt="" width="640" height="379" srcset="/wp-content/uploads/2018/04/sm30-02.png 648w, /wp-content/uploads/2018/04/sm30-02-300x178.png 300w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>Die Darstellung im Baum ist entsprechend und ich kann mit einem Doppelklick auf ein Material schnell alle Einträge auswählen, die dieses Material enthalten:</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2018/04/sm30-07.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-1018441" src="https://tricktresor.com/wp-content/uploads/2018/04/sm30-07.png" alt="" width="800" height="293" srcset="/wp-content/uploads/2018/04/sm30-07.png 800w, /wp-content/uploads/2018/04/sm30-07-300x110.png 300w, /wp-content/uploads/2018/04/sm30-07-768x281.png 768w" sizes="(max-width: 800px) 100vw, 800px" /></a></p>
<h2>Wo bin ich</h2>
<p>Eine Schwäche der Baumdarstellung ist, dass ich nicht genau, bzw. nicht gut erkennen kann, wo ich mich gerade befinde. Leider sind die Methoden, die den Aufbau der Hierarchie steuern als PRIVATE Methoden angelegt. Es ist also nicht möglich, die Klasse zu beerben und entsprechend anzupassen.</p>
<p>Ich fände es sinnvoll, wenn ich diesem Falle der Eintrag nicht 1000, 2000 usw. heißen würde, sondern &#8220;Verkaufsorganisation 1000&#8221; usw. Das würde deutlich machen, welche Hierarchiestufe es ist.</p>
<p>Eine einfache Möglichkeit habe ich jedoch gefunden, um die Darstellung anzupassen. Es kann ein Gruppenstufen-Layout definiert werden. Hier ist es möglich, für jede Stufe der Hierarchie ein Icon zu definieren. Da man im Icon auch eine Quickinfo mitgeben kann, lässt sich folgende Ausgabe erzeugen:</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2018/04/sm30-04.png"><img loading="lazy" decoding="async" class="alignnone size-large wp-image-1018436" src="https://tricktresor.com/wp-content/uploads/2018/04/sm30-04.png" alt="" width="205" height="125" /></a></p>
<p>Wenn man im Layout des SAPGUI einstellt, dass die Quickinfo sofort angezeigt wird, ist das eine akzeptable Lösung.</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2018/04/sm30-08.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-1018442" src="https://tricktresor.com/wp-content/uploads/2018/04/sm30-08.png" alt="" width="795" height="257" srcset="/wp-content/uploads/2018/04/sm30-08.png 795w, /wp-content/uploads/2018/04/sm30-08-300x97.png 300w, /wp-content/uploads/2018/04/sm30-08-768x248.png 768w" sizes="(max-width: 795px) 100vw, 795px" /></a></p>
<h2>Doppelklick</h2>
<p>Um die Navigation so einfach und intuitiv wie möglich zu machen, habe ich nicht nur NODE_DOUBLE_CLICK ausprogrammiert, sondern auch ITEM_DOUBLE_CLICK. Ich finde es immer nervig, wenn man irgendwo draufklickt und nichts passiert. Oder wenn man nur ein Element angeklickt hat und dann die Meldung kommt: &#8220;Bitte markieren Sie einen Knoten&#8221;.</p>
<h2>Call Screen</h2>
<p>Leider hat die Lösung eine große Macke: Da mit jedem Doppelklick der Tabellenpflegedialog erneut aufgerufen wird, wird mit jedem Aufruf ein CALL SCREEN ausgeführt. Das ist jedoch nur etwa 50 mal möglich.</p>
<p>Ein LEAVE TO SCREEN 0 sorgt zwar dafür, dass die Aufrufhierarchie wieder abgebaut wird, allerdings gibt es bei der Verwendung von LEAVE TO SCREEN 0 in der Doppelklick-Eventhandlermethode merkwürdige Seiteneffekte beim Blättern im Pflegedialog.</p>
<p>Ich habe leider keine Möglichkeit gefunden, um die Daten direkt im View zu aktualisieren, ohne den VIEW_MAINTENANCE_CALL erneut auszuführen.</p>
<h2>Weitere Infos</h2>
<p>Um möglichst viele Informationen über den Tabellenpflegedialog zu bekommen &#8211; und auch um zu wissen, ob überhaupt ein Pflegedialog existiert <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /> &#8211; rufe ich den Baustein VIEW_GET_DDIC_INFO auf. In der Tabelle TVDIR, die der Baustein unter anderem liest, steht zum Beispiel, in welcher Funktionsgruppe der Pflegedialog erstellt wurde. Das ist wichtig für externe Perform-aufrufe, mit denen man evtl. Daten manipulieren möchte. Es gibt zum Beispiel die Routine VIM_SET_GLOBAL_FIELD_VALUE, mit der globale Felder geändert werden können:</p>
<pre class="lang:abap decode:true">DATA(prog) = |SAPL{ ms_tvdir-area }|.
DATA(rc) TYPE i.
PERFORM vim_set_global_field_value 
     IN PROGRAM (prog) 
  USING 'VIM_NEXT_SCREEN' 
        'N' 
        '0' 
         rc.</pre>
<p>Das funktioniert aber nur, wenn auch der Aufruf &#8220;extern&#8221; erfolgt. Für einen externen Aufruf müssen ein paar sehr intime Infos übergeben werden, die aber fast alle vom VIEW_GET_DDIC_INFO ermittelt werden.</p>
<p>Mit der Routine TABLE_CALL_INFO und der Funktion &#8220;READ&#8221; werden die Daten gelesen und mit der Funktion &#8220;EDIT&#8221; werden die Daten im Änderungsmodus dargestellt.</p>
<pre class="lang:abap decode:true">    DATA(prog) = |SAPL{ ms_tvdir-area }|.
    PERFORM table_call_function IN PROGRAM (prog)
     TABLES lt_dba_sellist
            lt_dpl_sellist
            mt_x_header
            mt_x_namtab
            lt_excl_func
      USING 'READ'
            'VERY_SHORT'
            lv_updflag.

    PERFORM table_call_function IN PROGRAM (prog)
     TABLES lt_dba_sellist
            lt_dpl_sellist
            mt_x_header
            mt_x_namtab
            lt_excl_func
      USING 'EDIT'
            'VERY_SHORT'
            lv_updflag.</pre>
<p>Ich habe es, wie gesagt, leider nicht geschafft, die Daten nur zu aktualisieren, nachdem der View einmal dargestellt wurde.</p>
<h2>Filterung</h2>
<p>Normalerweise kann man in einem ALV Daten filtern. Der CL_GUI_ALV_SIMPLE_TREE basiert auf einem ALV aber leider kann hier nicht gefiltert werden. Die Funktion müsste aber leicht nachgestellt werden können. Eventuell kümmere ich mich da später noch mal drum.</p>
<h2>Select-Options</h2>
<p>Sinnvoll wäre es natürlich auch, ein Selektionsbild für den View anzubieten, so dass der Anwender eine Vorauswahl treffen kann.</p>
<p>Dies müsste mit den freien Selektionsbedingungen abbildbar sein, aber da hatte ich bisher noch keine Lust zu. In diesem Beitrag steht jedoch, wie diese zu verwenden sind: <a href="https://tricktresor.com/blog/dynamisches-selektionsbild/">Dynamisches Selektionsbild</a></p>
<p>Mit dem Funktionsbaustein VIEW_RANGETAB_TO_SELLIST können die Selektionsoptionen einfach in die für den Pflegedialog notwendige Selektionstabelle überführt werden.</p>
<h2>AbapGit</h2>
<p>Der gesamte Code inklusive Tabellendefinition und Tabellenpflegedialog steht bei <a href="https://github.com/tricktresor">github.com</a>:</p>
<p><a href="https://github.com/tricktresor/blog">https://github.com/tricktresor/blog</a></p>
<h2>Coding</h2>
<pre class="lang:abap decode:true ">REPORT ztrcktrsr_sm30_navigation.

PARAMETERS p_table TYPE tabname DEFAULT 'ZTT_DEMO1'.

CLASS lcl_tree DEFINITION.
  PUBLIC SECTION.
    TYPES tt_sellist           TYPE STANDARD TABLE OF vimsellist.

    DATA mo_tree               TYPE REF TO cl_gui_alv_tree_simple.
    DATA mt_sort               TYPE lvc_t_sort. "Sortiertabelle
    DATA mr_data               TYPE REF TO data.
    DATA ms_tvdir              TYPE tvdir.
    DATA mv_callstack_counter  TYPE i.

    DATA mt_sellist            TYPE STANDARD TABLE OF vimsellist.
    DATA mt_x_header           TYPE STANDARD TABLE OF vimdesc.
    DATA mt_x_namtab           TYPE STANDARD TABLE OF vimnamtab.

    METHODS handle_node_double_click
                  FOR EVENT node_double_click OF cl_gui_alv_tree_simple
      IMPORTING grouplevel index_outtab.
    METHODS handle_item_double_click
                  FOR EVENT item_double_click OF cl_gui_alv_tree_simple
      IMPORTING grouplevel index_outtab fieldname.
    METHODS build_sort_table.
    METHODS register_events.
    METHODS set_view IMPORTING viewname TYPE clike RAISING cx_axt.
    METHODS get_view_data.
    METHODS init_tree.
    METHODS constructor.
    METHODS view_maintenance_call IMPORTING it_sellist TYPE tt_sellist.

ENDCLASS.

DATA main TYPE REF TO lcl_tree.

CLASS lcl_tree IMPLEMENTATION.
  METHOD constructor.
  ENDMETHOD.

  METHOD set_view.
    SELECT SINGLE * FROM tvdir INTO ms_tvdir WHERE tabname = viewname.
    IF sy-subrc &gt; 0.
      RAISE EXCEPTION TYPE cx_axt.
    ENDIF.
  ENDMETHOD.

  METHOD handle_item_double_click.
    "Pass click on item to handle_node_double_click
    handle_node_double_click(
      grouplevel   = grouplevel
      index_outtab = index_outtab ).

  ENDMETHOD.

  METHOD handle_node_double_click.

    FIELD-SYMBOLS &lt;lt_data&gt;            TYPE STANDARD TABLE.
    ASSIGN mr_data-&gt;* TO &lt;lt_data&gt;.
    DATA lt_dba_sellist                TYPE STANDARD TABLE OF vimsellist.
    DATA ls_dbasellist                 TYPE  vimsellist.

    "Get current hierarchy
    mo_tree-&gt;get_hierarchy( IMPORTING et_sort = DATA(lt_sort) ).

    IF grouplevel = space.
      "clicked on entry
      ASSIGN &lt;lt_data&gt;[ index_outtab ] TO FIELD-SYMBOL(&lt;ls_data&gt;).
      CHECK sy-subrc = 0.

      LOOP AT lt_sort INTO DATA(ls_sort).
        ASSIGN COMPONENT ls_sort-fieldname OF STRUCTURE &lt;ls_data&gt; TO FIELD-SYMBOL(&lt;lv_value&gt;).
        IF sy-subrc &lt;&gt; 0.
          EXIT.
        ENDIF.
        APPEND INITIAL LINE TO lt_dba_sellist ASSIGNING FIELD-SYMBOL(&lt;ls_sellist&gt;).
        &lt;ls_sellist&gt;-viewfield = ls_sort-fieldname.
        &lt;ls_sellist&gt;-operator  = 'EQ'.
        &lt;ls_sellist&gt;-value     = &lt;lv_value&gt;.
        &lt;ls_sellist&gt;-and_or    = 'AND'.
        READ TABLE mt_x_namtab TRANSPORTING NO FIELDS WITH KEY viewfield = ls_sort-fieldname.
        &lt;ls_sellist&gt;-tabix     = sy-tabix.
      ENDLOOP.

    ELSE.
      "Clicked on hierarchy node
      ASSIGN &lt;lt_data&gt;[ index_outtab ] TO &lt;ls_data&gt;.
      IF sy-subrc = 0.
        LOOP AT lt_sort INTO ls_sort.
          "Fill up all field from start of hierarchy to clicked node
          ASSIGN COMPONENT ls_sort-fieldname OF STRUCTURE &lt;ls_data&gt; TO &lt;lv_value&gt;.
          IF sy-subrc &lt;&gt; 0.
            EXIT.
          ENDIF.
          APPEND INITIAL LINE TO lt_dba_sellist ASSIGNING &lt;ls_sellist&gt;.
          &lt;ls_sellist&gt;-viewfield = ls_sort-fieldname.
          &lt;ls_sellist&gt;-operator  = 'EQ'.
          &lt;ls_sellist&gt;-value     = &lt;lv_value&gt;.
          &lt;ls_sellist&gt;-and_or    = 'AND'.
          READ TABLE mt_x_namtab TRANSPORTING NO FIELDS WITH KEY viewfield = ls_sort-fieldname.
          &lt;ls_sellist&gt;-tabix     = sy-tabix.
          IF ls_sort-fieldname = grouplevel.
            EXIT.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.

    CHECK &lt;ls_data&gt; IS ASSIGNED.

    IF mv_callstack_counter &gt; 50.
      MESSAGE 'Navigation not possible anymore. Sorry' TYPE 'I'.
      RETURN. "handle_double_click
    ENDIF.

    ADD 1 TO mv_callstack_counter.

    view_maintenance_call( lt_dba_sellist ).

  ENDMETHOD.


  METHOD get_view_data.

    FIELD-SYMBOLS &lt;lt_data&gt; TYPE STANDARD TABLE.
    CREATE DATA mr_data TYPE STANDARD TABLE OF (ms_tvdir-tabname).
    ASSIGN mr_data-&gt;* TO &lt;lt_data&gt;.


    "Get info about table/ view
    CALL FUNCTION 'VIEW_GET_DDIC_INFO'
      EXPORTING
        viewname        = ms_tvdir-tabname
      TABLES
        sellist         = mt_sellist
        x_header        = mt_x_header
        x_namtab        = mt_x_namtab
      EXCEPTIONS
        no_tvdir_entry  = 1
        table_not_found = 2
        OTHERS          = 3.
    IF sy-subrc = 0.
      "Get data of view
      CALL FUNCTION 'VIEW_GET_DATA'
        EXPORTING
          view_name = ms_tvdir-tabname
        TABLES
          data      = &lt;lt_data&gt;
        EXCEPTIONS
          OTHERS    = 6.
    ENDIF.

  ENDMETHOD.                               " BUILD_OUTTAB

  METHOD build_sort_table.

    DATA ls_sort TYPE lvc_s_sort.
    DATA lv_idx  TYPE i.

    LOOP AT mt_x_namtab INTO DATA(ls_namtab)
    WHERE keyflag   = abap_true
      AND datatype &lt;&gt; 'CLNT'.
      ADD 1 TO lv_idx.
      ls_sort-fieldname = ls_namtab-viewfield.
      ls_sort-seltext   = ls_namtab-scrtext_l.
      ls_sort-spos      = lv_idx.
      ls_sort-up        = abap_true.
      APPEND ls_sort TO mt_sort.
    ENDLOOP.

  ENDMETHOD.                               " BUILD_SORT_TABLE


  METHOD register_events.

    mo_tree-&gt;set_registered_events( VALUE #(
          "Used here for applying current data selection
          ( eventid = cl_gui_column_tree=&gt;eventid_node_double_click )
          ( eventid = cl_gui_column_tree=&gt;eventid_item_double_click )
          "Important! If not registered nodes will not expand -&gt;No data
          ( eventid = cl_gui_column_tree=&gt;eventid_expand_no_children ) ) ).

    SET HANDLER handle_node_double_click FOR mo_tree.
    SET HANDLER handle_item_double_click FOR mo_tree.

  ENDMETHOD.                               " register_events


  METHOD init_tree.

    get_view_data( ).
    build_sort_table( ).

    DATA(docker) = NEW cl_gui_docking_container(
                            ratio = 25
                            side  = cl_gui_docking_container=&gt;dock_at_left
                            dynnr = CONV #( ms_tvdir-liste )
                            repid = |SAPL{ ms_tvdir-area }| "'SAPLSVIM'
                            no_autodef_progid_dynnr = abap_false ).

* create tree control
    mo_tree = NEW #( i_parent              = docker
                     i_node_selection_mode = cl_gui_column_tree=&gt;node_sel_mode_multiple
                     i_item_selection      = 'X'
                     i_no_html_header      = ''
                     i_no_toolbar          = '' ).



* register events
    register_events( ).


    FIELD-SYMBOLS &lt;lt_data&gt; TYPE STANDARD TABLE.
    ASSIGN mr_data-&gt;* TO &lt;lt_data&gt;.

    DATA lt_grouplevel        TYPE lvc_t_fimg.
    DATA ls_grouplevel        TYPE lvc_s_fimg.
    DATA lv_field_description TYPE text50.
    DATA lt_dba_sellist       TYPE STANDARD TABLE OF vimsellist.

    LOOP AT mt_sort INTO DATA(ls_sort).
      ls_grouplevel-grouplevel = ls_sort-fieldname.
      lv_field_description = mt_x_namtab[ viewfield = ls_sort-fieldname ]-scrtext_l.
      CALL FUNCTION 'ICON_CREATE'
        EXPORTING
          name       = 'ICON_OPEN_FOLDER'
          text       = ls_sort-fieldname
          info       = lv_field_description
          add_stdinf = ' '
        IMPORTING
          result     = ls_grouplevel-exp_image.
      CALL FUNCTION 'ICON_CREATE'
        EXPORTING
          name       = 'ICON_CLOSED_FOLDER'
          text       = ls_sort-fieldname
          info       = lv_field_description
          add_stdinf = ' '
        IMPORTING
          result     = ls_grouplevel-n_image.
      APPEND ls_grouplevel TO lt_grouplevel.
    ENDLOOP.

* create hierarchy
    CALL METHOD mo_tree-&gt;set_table_for_first_display
      EXPORTING
        i_save               = 'A'
        is_variant           = value #( report = sy-repid username = sy-uname )
        i_structure_name     = ms_tvdir-tabname
        it_grouplevel_layout = lt_grouplevel
      CHANGING
        it_sort              = mt_sort
        it_outtab            = &lt;lt_data&gt;.

    "expand first level
    mo_tree-&gt;expand_tree( 1 ).

    " optimize column-width
    CALL METHOD mo_tree-&gt;column_optimize
      EXPORTING
        i_start_column = mt_sort[ 1 ]-fieldname
        i_end_column   = mt_sort[ lines( mt_sort ) ]-fieldname.

    view_maintenance_call( lt_dba_sellist ).

  ENDMETHOD.

  METHOD view_maintenance_call.

    CALL FUNCTION 'VIEW_MAINTENANCE_CALL'
      EXPORTING
        action      = 'S'
        view_name   = ms_tvdir-tabname
      TABLES
        dba_sellist = it_sellist
      EXCEPTIONS
        OTHERS      = 15.

  ENDMETHOD.
ENDCLASS.


START-OF-SELECTION.
  CHECK main IS INITIAL.
  main = NEW #( ).
  TRY.
      main-&gt;set_view( viewname = p_table ).
      main-&gt;init_tree( ).
    CATCH cx_axt.
  ENDTRY.</pre>
<p>&nbsp;</p>
<p>Der Beitrag <a href="/blog/pflegeview-mit-datennavigation/">Pflegeview mit Datennavigation</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Fibonacci</title>
		<link>/blog/fibonacci/</link>
		
		<dc:creator><![CDATA[Enno Wulff]]></dc:creator>
		<pubDate>Tue, 10 Oct 2017 10:58:46 +0000</pubDate>
				<category><![CDATA[Reports]]></category>
		<category><![CDATA[Info/ Doku/ Demo]]></category>
		<category><![CDATA[Performance]]></category>
		<category><![CDATA[VERGLEICH]]></category>
		<category><![CDATA[Fibonacci]]></category>
		<category><![CDATA[Berechnung]]></category>
		<guid isPermaLink="false">https://tricktresor.com/?p=1018140</guid>

					<description><![CDATA[<p>Ein kleiner Vergleich von verschiedenen Berechnungsarten für Fibonacci-Zahlen in ABAP. Die Unterschiede sind enorm...</p>
<p>Der Beitrag <a href="/blog/fibonacci/">Fibonacci</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Ein kleines Beispielprogramm um die verschiedenen Arten der Berechnung von Fibonacci-Zahlen und deren Geschwindigkeit zu demonstrieren.</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2017/10/fibonacci.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-1018141" src="https://tricktresor.com/wp-content/uploads/2017/10/fibonacci.png" alt="" width="586" height="248" srcset="/wp-content/uploads/2017/10/fibonacci.png 586w, /wp-content/uploads/2017/10/fibonacci-300x127.png 300w" sizes="(max-width: 586px) 100vw, 586px" /></a></p>
<p>Ursprünglich habe ich das Programm auf Grund eines Beitrags im ABAP-Forum geschrieben (der aber leider gelöscht wurde) und um die verschiedenen Arten der Berechnung zu vergleichen. Hauptsächlich sollte es ein Vergleich sein zwischen der rekursiven und der iterativen Variante. Dazu gekommen ist dann noch eine Lösung, die mit einer internen Tabelle arbeitet. Ausschlaggebend für die Veröffentlichung war dann ein Beispiel von Lars Hvam dafür, wie man <strong>nicht</strong> programmieren sollte. Wie man an den Ergebnissen sieht, auch im Sinne der schlechten Performance&#8230;</p>
<h2>Code</h2>
<pre class="lang:abap decode:true" title="Berechnung Fibonacci-Zahlen">REPORT zz_fibonacci.

DATA result_f TYPE f.
DATA start    TYPE i.
DATA stopp    TYPE i.
DATA i        TYPE i.

PARAMETERS p_n       TYPE i.
PARAMETERS p_reku RADIOBUTTON GROUP b USER-COMMAND space.
PARAMETERS p_iter RADIOBUTTON GROUP b.
PARAMETERS p_tabl RADIOBUTTON GROUP b.
PARAMETERS p_hvam RADIOBUTTON GROUP b.
PARAMETERS p_res  TYPE text50 MODIF ID x.
PARAMETERS p_time TYPE i      MODIF ID x.

CLASS lcl_fibonacci DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS calc_rekursiv IMPORTING n TYPE i RETURNING VALUE(result) TYPE f.
    CLASS-METHODS calc_iterativ IMPORTING n TYPE i RETURNING VALUE(result) TYPE f.
    CLASS-METHODS calc_read_table IMPORTING x TYPE i RETURNING VALUE(result) TYPE f.
    CLASS-METHODS calc_hvam IMPORTING n TYPE i RETURNING VALUE(r) TYPE f.
  PRIVATE SECTION.
    CLASS-METHODS f IMPORTING i TYPE f RETURNING VALUE(f) TYPE f.
ENDCLASS.

CLASS lcl_fibonacci IMPLEMENTATION.

  METHOD calc_iterativ.

    DATA f1 TYPE f VALUE 0.
    DATA f2 TYPE f VALUE 1.
    DATA x  TYPE f VALUE 0.

    IF n &lt;= 0.
      result = 0.
    ELSEIF n = 1.
      result = 1.
    ELSE.
      x = n - 1.
      DO x TIMES.
        result = f1 + f2.
        f1 = f2.
        f2 = result.

      ENDDO.
    ENDIF.

  ENDMETHOD.

  METHOD calc_rekursiv.
    DATA f TYPE f.
    f = n.
    result = f( f ).
  ENDMETHOD.

  METHOD calc_read_table.
    "http://www.abapforum.com/forum/viewtopic.php?f=1&amp;t=21045

    TYPES BEGIN OF ts_fibonacci.        "Strukturtyp
    TYPES n         TYPE i.             "Zählvariable    (Spalte)
    TYPES fib_n     TYPE i.             "Fibonacci-Zahl  (Spalte)
    TYPES rechnung  TYPE string.        "Rechenweg       (Spalte)
    TYPES END OF ts_fibonacci.

    DATA gf_zahl1 TYPE i.
    DATA gf_zahl1_s TYPE string.
    DATA gf_zahl2 TYPE i.
    DATA gf_zahl2_s TYPE string.
    DATA gt_fibzahl TYPE TABLE OF ts_fibonacci.     "Tabelle
    DATA gs_fib TYPE ts_fibonacci.

    DO x TIMES.

      IF sy-index = 1 OR sy-index = 2.
        gs_fib-n = sy-index.
        gs_fib-fib_n = 1.
        gs_fib-rechnung = '-'.

      ELSE.
        READ TABLE gt_fibzahl
        INTO gs_fib
        INDEX sy-index - 1.
        gf_zahl1 = gs_fib-fib_n.

        READ TABLE gt_fibzahl
        INTO gs_fib
        INDEX sy-index - 2.
        gf_zahl2 = gs_fib-fib_n.

        gs_fib-fib_n = gf_zahl1 + gf_zahl2.
        gs_fib-n = sy-index.
        gf_zahl1_s = gf_zahl1.
        gf_zahl2_s = gf_zahl2.
        CONCATENATE gf_zahl1_s '+' gf_zahl2_s INTO gs_fib-rechnung SEPARATED BY space.
      ENDIF.

      APPEND gs_fib TO gt_fibzahl.
      CLEAR gs_fib.

    ENDDO.

    READ TABLE gt_fibzahl INDEX lines( gt_fibzahl ) INTO gs_fib.
    result = gs_fib-fib_n.

  ENDMETHOD.

  METHOD f.
    DATA x TYPE f.
    DATA y TYPE f.

    IF i &lt;= 0.
      f = 0.
    ELSEIF i = 1.
      f = 1.
    ELSE.
      x = i - 2.
      y = i - 1.
      f = f( x ) + f( y ).
    ENDIF.
  ENDMETHOD.

  METHOD calc_hvam.

    "negative example of Lars Hvam for how _NOT_ to code!
    "https://gist.github.com/larshp/cc5326dec8fe413bdc29e4d6b8c64b4f
    DATA n1 TYPE i.
    DATA n2 TYPE i.
    DATA r1 TYPE p.
    DATA r2 TYPE f.

    n2 = n - 1.
    n1 = n2 - 1.
    IF n = 1.
      r = n.
    ELSEIF n := 2.
      r = n - 1.
    ELSE.
      r2 = calc_hvam( n1 ).
      r1 = calc_hvam( n2 ).
    ENDIF.
    r = r + r1 + r2.

  ENDMETHOD.

ENDCLASS.



AT SELECTION-SCREEN OUTPUT.
  LOOP AT SCREEN.
    IF screen-group1 = 'X'.
      screen-input = '0'.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.

  GET RUN TIME FIELD start.
  CASE abap_true.
    WHEN p_iter.
      result_f = lcl_fibonacci=&gt;calc_iterativ( p_n ).
    WHEN p_reku.
      result_f = lcl_fibonacci=&gt;calc_rekursiv( p_n ).
    WHEN p_tabl.
      result_f = lcl_fibonacci=&gt;calc_read_table( p_n ).
    WHEN p_hvam.
      result_f = lcl_fibonacci=&gt;calc_hvam( p_n ).
  ENDCASE.

  WRITE result_f TO p_res EXPONENT 0 DECIMALS 0 LEFT-JUSTIFIED.
  GET RUN TIME FIELD stopp.
  p_time = stopp - start.


START-OF-SELECTION.

  DO p_n TIMES.
    i = sy-index.

    GET RUN TIME FIELD start.
    CASE abap_true.
      WHEN p_iter.
        result_f = lcl_fibonacci=&gt;calc_iterativ( i ).
      WHEN p_reku.
        result_f = lcl_fibonacci=&gt;calc_rekursiv( i ).
      WHEN p_tabl.
        result_f = lcl_fibonacci=&gt;calc_read_table( i ).
    ENDCASE.

    WRITE result_f TO p_res EXPONENT 0 DECIMALS 0 LEFT-JUSTIFIED.
    WRITE: / i, p_res.

  ENDDO.

  GET RUN TIME FIELD stopp.
  p_time = stopp - start.

  WRITE: / 'Time:', p_time.</pre>
<p>&nbsp;</p>
<p>Der Beitrag <a href="/blog/fibonacci/">Fibonacci</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Datenstrukturen EXPORT TO MEMORY</title>
		<link>/blog/datenstrukturen-export-to-memory/</link>
		
		<dc:creator><![CDATA[Enno Wulff]]></dc:creator>
		<pubDate>Tue, 19 Sep 2017 13:38:45 +0000</pubDate>
				<category><![CDATA[Reports]]></category>
		<category><![CDATA[Info/ Doku/ Demo]]></category>
		<category><![CDATA[Programmierung]]></category>
		<category><![CDATA[database]]></category>
		<category><![CDATA[report]]></category>
		<category><![CDATA[export to database]]></category>
		<category><![CDATA[import from database]]></category>
		<guid isPermaLink="false">https://tricktresor.com/?p=1018124</guid>

					<description><![CDATA[<p>Die Befehle EXPORT TO MEMORY und IMPORT FROM MEMORY sind einfach zu benutzen und sind eine große Hilfe bei der Speicherung von Daten jeder Art. Bei der Verwendung solltest du dir jedoch über einige Dinge im Klaren sein. Ich beleuchte hier ein paar Aspekte der beiden mächtigen Befehle EXPORT und IMPORT.</p>
<p>Der Beitrag <a href="/blog/datenstrukturen-export-to-memory/">Datenstrukturen EXPORT TO MEMORY</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Die Befehle EXPORT TO MEMORY und IMPORT FROM MEMORY sind einfach zu benutzen und sind eine große Hilfe bei der Speicherung von Daten jeder Art. Mit dem <em>Medium</em> DATABASE werden die Daten in einer <em>Clustertabelle</em> gespeichert. Die bekannteste ist INDX. Zusätzlich muss ein <em>Gebiet</em> angegeben werden (zweistelliges Kürzel) und eine <em>ID</em>.</p>
<p>Mit folgendem kleinen Testprogramm zeige ich dir, wie du einen strukturierten Datensatz ablegen und wieder laden kannst.</p>
<h2>Coding</h2>
<pre class="lang:abap decode:true">REPORT.

*== Typisierung der Datenstruktur
TYPES: BEGIN OF ty_data,
         key    TYPE matnr,
         mara   TYPE mara,
         t_mard TYPE STANDARD TABLE OF mard WITH DEFAULT KEY,
         t_makt TYPE STANDARD TABLE OF makt WITH DEFAULT KEY,
       END OF ty_data.

*== Datenstruktur
DATA s_data TYPE ty_data.

*== Auswahl: Import oder Export der Daten
PARAMETERS p_import RADIOBUTTON GROUP mode DEFAULT 'X'.
PARAMETERS p_export RADIOBUTTON GROUP mode.
*== Zu lesendes Element (MaterialnummeR)
PARAMETERS p_matnr TYPE matnr DEFAULT '1000002'.

START-OF-SELECTION.

  CASE 'X'.
    WHEN p_export.
      "MARA-Daten lesen
      SELECT SINGLE * FROM mara INTO @s_data-mara WHERE matnr = @p_matnr.
      IF sy-subrc = 0.
        "Schlüssel setzen
        s_data-key = p_matnr.
        "Zusätzliche Tabellen lesen
        SELECT * FROM mard INTO TABLE @s_data-t_mard WHERE matnr = @p_matnr.
        SELECT * FROM makt INTO TABLE @s_data-t_makt WHERE matnr = @p_matnr.
        "Daten in INDX exportieren
        EXPORT data FROM s_data TO DATABASE indx(z1) ID p_matnr.
      ENDIF.

    WHEN p_import.
      "Exportierte Daten zum Schlüssel wieder einlesen
      IMPORT data TO s_data FROM DATABASE indx(z1) ID p_matnr.
  ENDCASE.

  "Daten im Debugger überprüfen
  BREAK-POINT.</pre>
<p>Im Debugger sehen die Daten wie folgt aus:</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2017/09/s_data.png"><img loading="lazy" decoding="async" class="alignnone wp-image-1018125 size-full" src="https://tricktresor.com/wp-content/uploads/2017/09/s_data.png" alt="" width="559" height="197" srcset="/wp-content/uploads/2017/09/s_data.png 559w, /wp-content/uploads/2017/09/s_data-300x106.png 300w" sizes="(max-width: 559px) 100vw, 559px" /></a></p>
<h2>Vorteile</h2>
<p>Die Handhabung der beiden Befehle zum Exportieren und Einlesen der Daten ist extrem einfach. Auf diese Weise können einfache Feldleisten, interne Tabellen oder auch komplexe Datenstrukturen unkompliziert in der Datenbank abgelegt werden.</p>
<p>Die Testdaten zu Funktionsbausteinen werden übrigens auf diese Weise verwaltet (Clustertabelle EUFUNC und Gebiet FL).</p>
<p>Die Technik gibt es bereits sehr lange und dürfte ausreichend schnell und sicher in der Anwendung sein.</p>
<h2>Nachteile</h2>
<h3>Änderbarkeit</h3>
<p>Der große Nachteil bei der Verwendung: Die Datenstrukturen müssen immer gleich bleiben. Sobald sich die Datenstrukturen ändern, kann es sein, dass der Import alter Daten nicht mehr funktioniert. Die größte Chance auf alte Daten zuzugreifen hat man noch, wenn neue Felder ans Ende der Struktur gesetzt werden. Werden Objekte aus der Mitte der Struktur gelöscht oder eingefügt, kann die Zuordnung der Daten nicht mehr erfolgen. Es erfolgt der Laufzeitfehler CONNE_IMPORT_WRONG_COMP_TYPE. Die gute Nachricht: Du kannst den Laufzeitfehler mit der Ausnahme CX_SY_IMPORT_MISMATCH_ERROR abfangen. Die zweite gute Nachricht: es gibt eine ebenfalls recht komfortable Alternative: <a href="https://tricktresor.com/blog/daten-dynamisch-verwalten/">Daten dynamisch verwalten</a></p>
<h3>Lesbarkeit</h3>
<p>Die Daten werden in einem Datencluster abgespeichert. Dieser Cluster sieht in etwa folgendermaßen aus:</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2017/09/indx.png"><img loading="lazy" decoding="async" class="alignnone wp-image-1018126 size-large" src="https://tricktresor.com/wp-content/uploads/2017/09/indx-1024x500.png" alt="" width="640" height="313" srcset="/wp-content/uploads/2017/09/indx-1024x500.png 1024w, /wp-content/uploads/2017/09/indx-300x146.png 300w, /wp-content/uploads/2017/09/indx-768x375.png 768w, /wp-content/uploads/2017/09/indx.png 1047w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>In der gespeicherten Tabelle kannst du also noch sehen, dass Einträge zu einer ID vorhanden sind, aber sie sind nicht mehr lesbar.</p>
<h3>Typsisierung</h3>
<p>Um die Daten aus der Clustertabelle wieder lesen zu können, musst du zwingend die Struktur der Daten kennen. Ansonsten wird es s o gut wie unmöglich, diese wieder sichtbar zu machen. Aber auch hier hilft der Tipp <a href="https://tricktresor.com/blog/daten-dynamisch-verwalten/">Daten dynamisch verwalten.</a></p>
<h3>Aufruf der Befehle</h3>
<p>Die Methode mit IMPORT TO DATABASE wird häufig in verschiedenen Programmen verwendet, um auf Daten zugreifen zu können, die eigentlich an anderer Stelle nicht mehr zur Verfügung stehen. Dadurch ist es häufig sehr schwer zu erkennen, wo das jeweilige Gegenstück des Befehls verwendet wird. Wenn du an einer Stelle über den IMPORT gestolpert bist, dann ist es eventuell sehr schwer, die Stelle zu finden, die den EXPORT macht und umgekehrt.</p>
<p>Aber auch hier gibt es eine einfache Lösung. Sie bedeutet einen kleinen Aufwand, sollte aber in jedem Fall gemacht werden: Der EXPORT und IMPORT der Daten wird in eine eigene Klasse ausgelagert. Export und Import erfolgen jeweils über die gleichnamige Methode der Klasse. So sind EXPORT und IMPORT für ein Objekt an einer Stelle vorhanden. Zusätzlich kann über einen Verwendungsnachweis der Aufruf ermittelt werden.</p>
<h2>Analyse</h2>
<p>Der Grund für diesen Artikel ist allerdings, dass ich heute erst &#8211; nachdem ich den Befehl schon mehrere Jahre lang verwendet habe &#8211; erfahren habe, dass es einen Report gibt, der die Struktur der Daten ausgibt: RSINDX00</p>
<p>Der Ausgabe des Reports sieht man sein Alter an&#8230; Erstellt wurde er vor über 15 Jahren. Aber, wenn alle Stricke reißen, so kann er eine gute Hilfe sein, um die gespeicherten Daten zu analysieren:</p>
<p><a href="https://tricktresor.com/wp-content/uploads/2017/09/rsindx00.png"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-1018127" src="https://tricktresor.com/wp-content/uploads/2017/09/rsindx00.png" alt="" width="662" height="728" srcset="/wp-content/uploads/2017/09/rsindx00.png 662w, /wp-content/uploads/2017/09/rsindx00-273x300.png 273w" sizes="(max-width: 662px) 100vw, 662px" /></a></p>
<p>Der Beitrag <a href="/blog/datenstrukturen-export-to-memory/">Datenstrukturen EXPORT TO MEMORY</a> erschien zuerst auf <a href="/">Tricktresor</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
